<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuranxu.github.io</id>
    <title>刻螺丝</title>
    <updated>2020-10-12T09:00:15.384Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuranxu.github.io"/>
    <link rel="self" href="https://wuranxu.github.io/atom.xml"/>
    <subtitle>欢迎来到我的小窝~这里不仅有博客，也有日记。</subtitle>
    <logo>https://wuranxu.github.io/images/avatar.png</logo>
    <icon>https://wuranxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 刻螺丝</rights>
    <entry>
        <title type="html"><![CDATA[推荐一个接口测试工具--Apifox]]></title>
        <id>https://wuranxu.github.io/post/tui-jian-yi-ge-jie-kou-ce-shi-gong-ju-apifox/</id>
        <link href="https://wuranxu.github.io/post/tui-jian-yi-ge-jie-kou-ce-shi-gong-ju-apifox/">
        </link>
        <updated>2020-10-12T08:31:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="apifox">Apifox</h3>
<pre><code>今天闲来无事，看到了这款工具。相当于出个小评测吧，说下自己的感受。先放地址:

[Apifox官网](https://www.apifox.cn/)

具体的介绍都可以在官网看到，官网会比我详细，下面来说说我自己的感受。
</code></pre>
<h3 id="感受">感受</h3>
<pre><code>首先呢，这个工具对于yapi、postman和jmeter的使用者来说肯定是很友好的，因为操作流程基本上一致。

大家可以看到他的首页，基本上长得很想postman的&quot;汉化版&quot;:
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://wuranxu.github.io/post-images/1602491849512.jpg" alt="" loading="lazy"></figure>
<pre><code>==但是, 他们也有区别==

postman是一个十分纯粹的http调用工具，只需要输入http的url、headers、body等信息即可，他十分轻量，虽然后面也迭代了不少的关于test的功能。

总的来看，这个工具是对接口文档/接口请求/接口测试的一次整合。

当然这种整合也带来了一些麻烦，也就是说你需要录入一个接口的相关信息才能完成对这个接口的请求。因为这毕竟是针对团队，针对自身接口的一个测试工具。所以情有可原，复杂点能够理解。

--

可是，当我觉得它复杂化了postman的时候，我发现它也有快捷调试的功能。因为有时候很多接口，可能是第三方的，比如我常常试用的[百度api](https://ai.baidu.com/) (这个是宝藏api)，我可能只是需要简单调用下，并不想那么麻烦，可能只需要随手一个调用即可。原来这个便捷调试也是存在的:
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://wuranxu.github.io/post-images/1602492392171.jpg" alt="" loading="lazy"></figure>
<pre><code>打开后长这样, 这才是最纯粹的postman呀！还是汉化版，爱了爱了！
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://wuranxu.github.io/post-images/1602492422864.jpg" alt="" loading="lazy"></figure>
<pre><code>那么有的同学可能会有疑问了，既然你就是个汉化版的postman，为什么我不用postman呢？

我想这个工具吸引我的可能有以下几点:

1. 它解决了我平时不写接口文档的问题，因为平时我自己开发接口完了以后，用postman去调试一下，后续可能需要搜索才能找到对应的数据，而且别人根本不知道这个接口怎么调用，只能口口相传。
2. 它支持换肤功能，对比postman，虽然二者UI类似。
3. 它的测试功能强于postman，支持直接导入接口文档当做测试用例。
4. 它完全支持mock功能，这点基本上和yapi提供的一致，如果后端接口还没编写完毕的时候前端已经可以开始通过mock开始调试了。
5. 如果有现有的接口文档工具，它支持了大部分主流数据的导入，比如yapi、rap、swagger等，接入门槛很低。
</code></pre>
<h3 id="写在最后">写在最后</h3>
<pre><code>这个工具，挺适合小团队，比如2-3人的项目组且公司没有内部统一的接口文档管理平台比如yapi或者rap2或者自研的，例如我要和一个朋友开发一个项目，那我觉得这个就很合适，适合自测，也适合前端提前介入开发，还能输出文档。

但是如果只是个人开发自己的项目或者很简单的项目，在接口数量不多的时候，对测试要求不高，不需要花费时间写测试脚本的时候，==postman还是最合适的工具==！

看后续apifox还有新的迭代计划，比如完成性能测试相关，但那时候我觉得可能会收费了吧，对于这种高级功能。其实本人比较欣赏他们的UI设计，毕竟是一个公司的产物，整个设计相对来说还是比较美观的。也期待他们的后续吧！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang下载指定版本（go get）]]></title>
        <id>https://wuranxu.github.io/post/golang-xia-zai-zhi-ding-ban-ben-go-get/</id>
        <link href="https://wuranxu.github.io/post/golang-xia-zai-zhi-ding-ban-ben-go-get/">
        </link>
        <updated>2020-09-29T05:41:48.000Z</updated>
        <content type="html"><![CDATA[<pre><code>是这样的，大概在去年的时候，自己学习grpc写了一些相关的代码包括proto和一些生成的pb。

但是今年发现grpc版本有更新，对应的protoc-gen-go这样的插件也进行了一番更新，而这些更新又和etcd不太兼容。所以为了降级，需要获取旧版本。

如果你用的还是GOPATH管理包，那么我建议你现在开始，使用==go module==来管理，当然这需要你的golang版本在1.11以上~

好了废话不多说了，直接上命令吧！
</code></pre>
<pre><code class="language-shell">go get -u -v github.com/golang/protobuf/protoc-gen-go@v1.2.7
</code></pre>
<pre><code>以上就是下载1.2.7版本protoc-gen-go的方式了！
</code></pre>
<h3 id="使用gomodule注意">使用GOMODULE注意</h3>
<pre><code>首先保证GO111MODULE变量是on, 如果是off的话，可在环境变量更新为on。
</code></pre>
<pre><code class="language-shell">export GO111MODULE=on
</code></pre>
<pre><code>或者更新~/.bash_profile文件设置此变量

如果遇到下载慢或者失败的时候，可以切换GOPROXY源:
</code></pre>
<ul>
<li>GOPROXY源</li>
</ul>
<pre><code class="language-shell"> export GOPROXY=https://goproxy.io 
</code></pre>
<ul>
<li>阿里云源</li>
</ul>
<pre><code class="language-shell">export GOPROXY=https://mirrors.aliyun.com/goproxy/ 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务相关思考(一)]]></title>
        <id>https://wuranxu.github.io/post/wei-fu-wu-xiang-guan-si-kao-yi/</id>
        <link href="https://wuranxu.github.io/post/wei-fu-wu-xiang-guan-si-kao-yi/">
        </link>
        <updated>2020-09-23T10:59:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="声明">声明</h3>
<pre><code>以下内容都是本人很片面的观点，如有错误，请帮忙纠正，非常感谢~
</code></pre>
<h3 id="背景">😢背景</h3>
<pre><code>随着咱们的服务越来越庞大，所编写的功能模块也越来越多，单体应用带来了以下问题：

1. 服务臃肿，一处细小改动往往需要重启所有业务服务；
2. 若某接口故障，则导致所有接口均不可用，可用性低；
3. 业务耦合度过高，不利于业务的扩展，常常会导致牵一发动全身的情况出现；
4. 不适合快速迭代开发，往往开发周期被拖得很长。
</code></pre>
<h3 id="问题">问题</h3>
<pre><code>既然问题出现了，那我们就需要对症下药。试想，我们将服务进行拆分，不同的服务对应不同的业务。

之前的模式好比，10个人在吃一块巨大的蛋糕，服务拆分以后就好像把蛋糕切成10块，然后每个人吃自己那块就行了。

但是咱们的后台系统，可不是吃蛋糕那么简单。思考一下服务拆分后会带来哪些问题？

1. 虽然完成了解耦的工作，但是对于业务有关联性的时候，双方怎么进行交流呢？也就是服务之间如何通信呢？
2. 服务需要统一的入口，假如拆分3个服务，那么每个服务需要占用1个端口，对于前端来说，它怎么知道什么url对应什么服务的地址呢？如果每个服务部署到多台机器呢？

等等~
</code></pre>
<h3 id="思考">思考</h3>
<pre><code>针对第一个问题，其实可以采用http请求进行通信，比如我的获取用户信息隶属于==userService==, 那么我找到对应的域名（ip）就可以进行相关接口的调用，拿到对应的用户信息。

但是！这个方案有个缺点，就是: 我们知道http协议是无状态的，也就是说我1秒钟前请求了这个接口，下一秒他还是会重新建立网络连接，所有流程再进行一遍，这对于服务器资源来说，算是一笔不小的开销。
</code></pre>
<h3 id="grpc">grpc</h3>
<pre><code>那么我们就需要用rpc来取代http协议，市场上有多种框架: grpc, thrift, dubbo等等。
</code></pre>
<p>我们今天就着重说一下<a href="https://grpc.io">grpc</a></p>
<pre><code>gRPC  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.

gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。

简单的说呢，它对比HTTP协议，优势很大。

再来说一下它的缺点:

- 学习门槛较高
- 需要编写proto文件
- 生成的rpc服务是tcp的，未暴露http接口给前端使用
</code></pre>
<h3 id="网关">网关</h3>
<pre><code>其实网关这个东西，也可以不需要，nginx足够使用了。针对第二个问题，其实主要是想给客户端提供一个统一的入口。比如针对https://abc.com/user/*这个路由，将其指向对应的userService即可。而且nginx也有自带的负载均衡的策略，想到这里我不禁陷入了沉思，我得思考一下为什么需要go的网关了~

大概查阅了一下相关资料，可能因为自研网关对比nginx来说定制化更容易吧。
</code></pre>
<p>以下内容参考自 <a href="https://www.v2ex.com/t/684586">关于微服务网关的选择</a>:</p>
<pre><code>&quot;nginx 性能虽强，但功能有限。我们一般只用来做负载均衡和反向代理。后面还是 gateway 来实现做身份验证、鉴权、限流、接口访问日志等功能。&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react hook]]></title>
        <id>https://wuranxu.github.io/post/react-hook/</id>
        <link href="https://wuranxu.github.io/post/react-hook/">
        </link>
        <updated>2020-09-21T09:38:16.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">🙃背景</h3>
<pre><code>在好奇心的驱使下，还是打开了==react hook==的大门，但是有些东西吧，还是得靠自己琢磨琢磨才能体会。</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">🙃背景</h3>
<pre><code>在好奇心的驱使下，还是打开了==react hook==的大门，但是有些东西吧，还是得靠自己琢磨琢磨才能体会。
</code></pre>
<!-- more -->
<h3 id="优势">优势</h3>
<pre><code>在react hook里，函数式组件也能有状态管理了。它大概长这样！
</code></pre>
<pre><code class="language-Javascript">import React, {useState, useEffect} from 'react';

export default () =&gt; {
    // count是该函数组件的属性, 初始值是0
    const [count, setCount] = useState(0);

    return (
        &lt;div onClick={()=&gt;setCount(count+1)}&gt;当前点击次数为{count}&lt;/div&gt;
    )
}
</code></pre>
<pre><code>对比以前，可以发现这样写出来简单粗暴，几乎可以说是让我放弃了class的编写，但是我想不明白的是，如果一个组件里面有很多state，岂不是要写很多setXXX. 也可能是我自己的组件太过于耦合了，其实该拆的地方应该要拆。

官方给出的解释就是以下好处: 
</code></pre>
<p>以下内容搬运自掘金: https://juejin.im/post/6844903908335173645</p>
<h3 id="为什么会有-hook">为什么会有 Hook?</h3>
<pre><code>在组件之间复用状态逻辑很难

React 提供了一些方法来实现组件的选择性渲染或复用，如 Render Props、高阶组件 等，但这些方法组成的组件也带来了“嵌套地狱”的问题，复杂了组件的结构，增大了阅读理解代码的难度。React 提供了自定义 Hook 来解决上面提到的问题。


复杂组件变得难以理解
在一些复杂的组件中往往都包含了较多的状态逻辑和方法，如组件常常在 componentDidMount 中获取数据。但是，同时在该生命周期中也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。一些原本没关联的的代码因为修改了相同的状态而冗杂在一起。当然 React 也引入了 Redux 用来实现状态管理，但这也引入了很多抽象概念，文件也相对应复杂起来。Hook 将组件中相互关联的部分拆分成更小的函数，而并非强制按照生命周期划分。


难以理解的 class
在组件中使用 class 时，开发者必须去理解 JavaScript 中 this 的工作方式，需要处理事件绑定等等，另外，class 还存在不能很好的压缩等问题。Hook 使你在非 class 的情况下可以使用更多的 React 特性。
</code></pre>
<h3 id="我这个初学者的理解手动微笑">我这个初学者的理解（手动微笑）</h3>
<pre><code>我是觉得这个hook给我带来最大的感受就是，一个组件的开发变得更加简单了。第一是因为函数组件本来就显得更简练，第二是可以用useEffect的第二个参数去处理生命周期，比之前的componentDidMount等更为简洁。关于使用方面，其实我自己还在使用dva的connect管理状态，用函数组件connect也能使用，所以暂时体会不到。先稍微记录下自己的感受，后面再更！</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刷题日记·开篇]]></title>
        <id>https://wuranxu.github.io/post/shua-ti-ri-ji-kai-pian/</id>
        <link href="https://wuranxu.github.io/post/shua-ti-ri-ji-kai-pian/">
        </link>
        <updated>2020-09-18T09:16:49.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://wuranxu.github.io/post-images/1600420645602.png" alt="" loading="lazy"></figure>
<pre><code>记录一下自己的刷题过程，里面可能有大概10%的抄答案，实际上估计刷了60道了吧。

😅说实话，做得多了，确实也慢慢熟练了一些吧。做题也是需要套路的，就好像自己以前s6之前从来不会玩旧版女警，改版以后也不会。有一次在诺克萨斯打排位，黄金分段。当时一级团拿了4杀，出门多一个十字镐，还是打不过对面奥巴马。不敢想象一盘被4个队友怒骂，硬撑到20分钟的场景了。于是我下决心一定要练好女警！

后面看了一些女警的教学，那段时间开始不断练习，之后女警已经成为我拿到手最有把握的英雄了。

做题目也是一样，其实什么事情都是一样，熟能生巧~
</code></pre>
<h3 id="为什么要刷题">为什么要刷题🤣</h3>
<pre><code>有的小伙伴儿可能会有一些疑问，觉得自己只是个测试，为什么要刷题？

但很多时候，就算你是测试甚至不是测开，外边公司也会对数据结构/算法有一定的要求。针对测开/开发来说，面试手撕算法就更加常见了！

根据本人这几年的面试经验来说，项目相关的问题是一方面，另一个很重要的方面就是算法题了。某些公司甚至每面都会有，本人在tx的3面就因为这个败下阵来，然而后悔并没有用~
</code></pre>
<ul>
<li>
<p>诀窍🤥</p>
<ul>
<li>
<p>链表:</p>
<ol>
<li>倒数第N个节点，可以用双指针，通过指针差将慢的指针停留在倒数第N个节点</li>
<li>链表的中间节点，其实也很简单，也是双指针，只不过是快慢指针，快指针一次走2步，慢指针一次走1步，这样快指针走完，慢指针就<mark>留在中间节点</mark>了。</li>
</ol>
<p>这样的套路还有很多，还有看到什么二叉树阿之类的，都别太怕，这也是说给我自己听的。其实做下来的感觉也就是模板套一下（当然只针对easy和部分medium），树就是递归，链表大多是while迭代。</p>
</li>
<li>
<p>HashMap:</p>
<p>很多都是用来临时存储数据，比如<a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>，就可以用hashmap来解决。</p>
<p>我们用hashmap的时候，可以知道key是不可重复的，很多时候是利用了这样的特点。</p>
</li>
</ul>
</li>
</ul>
<p>--</p>
<p>想起以前一个实况8队友的QQ签名：</p>
<p><mark>上一天自习不难，难的是上一辈自习！</mark></p>
<pre><code>后续我也会继续更新这个刷题过程，一方面是为了继续鞭策自己，另一方面就是为了加深自己对数据结构与算法的印象。加油吧！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://wuranxu.github.io/post/about/</id>
        <link href="https://wuranxu.github.io/post/about/">
        </link>
        <updated>2020-09-18T08:24:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>这是业余时间写东西的一个小网站啦</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>博主是一名测试开发工程师，目前在上海工作。平时喜欢捣鼓些测试相关的开发工作，是个不折不扣的技术宅。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>平时偶尔打打LOL，但是水平一直不怎么好。s3开始就是老黄金了，最近都只打大乱斗。有一起的可以加我一起玩呀~</p>
<p>艾欧尼亚：丶丶君已陌路丶丶</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>有想一起交流测试/开发技术的伙伴儿们，可以加群一起呀！<br>
🎧 QQ群号: 450505138</p>
<p>QQ: 619434176(偶尔不在)<br>
微信: <mark>wuranxu</mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写给大家的一个接口测试平台]]></title>
        <id>https://wuranxu.github.io/post/xie-gei-da-jia-de-yi-ge-jie-kou-ce-shi-ping-tai/</id>
        <link href="https://wuranxu.github.io/post/xie-gei-da-jia-de-yi-ge-jie-kou-ce-shi-ping-tai/">
        </link>
        <updated>2020-09-18T08:06:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>🍦初衷</p>
<p>在2018年的时候，来到这家公司，在领导的规划下，完成了接口测试平台从0到1的建设。可惜的是某些方面还是做的不够好吧~希望能够开发一套较为通用，服务大众的产品。毕竟世界上不只是那些大公司，还有很多才起步但没有合适工具支持的小公司。</p>
</li>
<li>
<p>🍩目前进度</p>
<p>基本上才处于<mark>起步阶段</mark>，也希望自己能够坚持下去吧~</p>
</li>
</ul>
]]></content>
    </entry>
</feed>