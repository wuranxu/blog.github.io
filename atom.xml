<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuranxu.github.io</id>
    <title>小克的blog</title>
    <updated>2020-11-12T02:50:55.433Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuranxu.github.io"/>
    <link rel="self" href="https://wuranxu.github.io/atom.xml"/>
    <subtitle>欢迎来到我的小窝~这里不仅有博客，也有日记。</subtitle>
    <logo>https://wuranxu.github.io/images/avatar.png</logo>
    <icon>https://wuranxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小克的blog</rights>
    <entry>
        <title type="html"><![CDATA[每日一题20201112（922. 按奇偶排序数组 II）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201112922-an-qi-ou-pai-xu-shu-zu-ii/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201112922-an-qi-ou-pai-xu-shu-zu-ii/">
        </link>
        <updated>2020-11-12T02:50:36.000Z</updated>
        <content type="html"><![CDATA[<h4 id="题目链接-922-按奇偶排序数组-ii">题目链接： <a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></h4>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-37d0c2bc9694c05a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<pre><code>很简单，搞懂问题的核心就行，假设现在有奇数在偶数位上，偶数在奇数位上。

那么我们要做的就是，找到分别在对方位置上的数字，然后交换他们就行。
</code></pre>
<pre><code class="language-Python">class Solution:
    def sortArrayByParityII(self, A: List[int]) -&gt; List[int]:
        # 判断数组大小是否小于等于1，是则直接返回数组
        if len(A) &lt;= 1:
            return A
        # 定义2个指针，i指向第一个偶数位，j指向第一个奇数位
        i, j = 0, 1
        # 循环结束的条件是i或者j超出数组范围
        while i &lt; len(A) and j &lt; len(A):
            # i不是偶数位且j不是奇数位 直接交换，并把i j分别挪到下一个位置
            if A[i] % 2 == 1 and A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 2
                j += 2
            # i不是偶数, j是奇数 那么j去下一个位置
            elif A[i] % 2 == 1:
                j += 2
            # j不是奇数 i去下一个位置
            elif A[j] % 2 == 0:
                i += 2
            # i j位置都正确
            else:
                i += 2
                j += 2
        return A
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-c410d82cda5fe8da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201109（15. 三数之和）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020110915-san-shu-zhi-he/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020110915-san-shu-zhi-he/">
        </link>
        <updated>2020-11-09T12:08:27.000Z</updated>
        <content type="html"><![CDATA[<p>题目链接:  <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-69e10b376ebe0244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="解法">解法</h4>
<ul>
<li>
<p><s>暴力法</s></p>
<p>首先可以确定的是暴力法的时间复杂度是O(N³), 所以基本上不考虑此等解法。</p>
</li>
<li>
<p>排序+双指针</p>
<p>思路是先将数组排序（从小到大），然后固定数组的第一位。</p>
<p>定义2个指针（左右指针）分别指向定位数组的后一位和数组最后一位。</p>
<p>如果3个数字加起来比0小，则左指针右移，循环继续。</p>
<p>如果3个数字加起来比0大，则右指针左移，循环继续。</p>
<p>如果3个数字等于0，说明找到了结果，将3个数字放入结果数组中并把左指针右移，右指针左移。</p>
<ol>
<li>
<p>这里需要注意的是，可能会有重复数据产生，为了不产生重复数据，需要确保左移/右移后的值与之前不一致。</p>
</li>
<li>
<p>如果从固定的数字大于0了，说明右侧不可能有结果了，因为右侧都是大于0的数字，加起来不会大于0了。</p>
</li>
<li>
<p>如果固定位置与上一个固定位置的值相同，也会产生重复数据，遇到直接跳过就行。</p>
</li>
</ol>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-1956974a795b240a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="最终代码">最终代码</h4>
<pre><code class="language-Python">class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        # 先对数组进行排序, 为了方便比较元素
        nums = sorted(nums)
        i = 0  # 数组起点
        result = []    # 结果
        while i &lt; len(nums):
            if nums[i] &gt; 0:
                # 大于0的数字可以直接跳过
                break
            if i &gt; 0 and nums[i] == nums[i-1]:
                # 与上一个固定位重复的数字直接跳过
                i += 1
                continue 
            front, back = i+1, len(nums)-1
            while front &lt; back:
                val = nums[i] + nums[back] + nums[front]
                if val &lt; 0:
                    # 说明需要增大数字, front+1
                    front += 1
                elif val &gt; 0:
                    # 说明需要缩小数字, back-1
                    back -= 1
                else:
                    result.append([nums[i], nums[back], nums[front]])
                    front += 1
                    back -= 1
                    # 保证没有重复数组
                    while front &lt; len(nums) and nums[front] == nums[front-1]:
                        front += 1
                    while back &gt;= 0 and nums[back] == nums[back+1]:
                        back -= 1
            i += 1
        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201106（169. 多数元素）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201106169-duo-shu-yuan-su/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201106169-duo-shu-yuan-su/">
        </link>
        <updated>2020-11-06T03:23:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-13c477602a678a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="hash表">hash表</h4>
<pre><code>1. 思路很简单，先遍历数组，存储每个元素的个数
2. 遍历hash表，拿到大于 n/2的数字，直接return
</code></pre>
<pre><code class="language-Python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        hash = dict()
        for n in nums:
            if n not in hash:
                hash[n] = 1
            else:
                hash[n] += 1
        for k, v in hash.items():
            if v &gt; len(nums) / 2:
                return k
        return -1

</code></pre>
<p>时间复杂度: O(N)<br>
空间复杂度: O(N)</p>
<h4 id="投票算法">投票算法</h4>
<pre><code>思路很简单，假设你是秦始皇，数组里面有很多其他国家，你们秦兵遇到自己人就+1，遇到其他人就-1，如果你超过了所有国家一半的兵力，那么最后活下来的肯定就是你的士兵。这里之所以能这么确定，是因为题目强调了一定存在多数元素！

代码思路是，开始遍历数组，如果当前的士兵数量是0，则把当前士兵设置为遍历到的元素，比如: 秦

接下来如果遇到秦，则count+1, 遇到的是赵或者其他士兵，则秦和赵士兵同归于尽。下一轮遍历，由于秦的count是0了，则将当前士兵设置为遍历到的士兵。
</code></pre>
<pre><code class="language-Python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        if len(nums) == 0:
            return -1
        # 当前士兵数量
        count = 0
        # 当前士兵
        current = None
        for n in nums:
            if count == 0:
                current = n
            count += 1 if n == current else -1
        return current

</code></pre>
<p>时间复杂度: O(N)<br>
空间复杂度: O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201105（771. 宝石与石头）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201105771-bao-shi-yu-shi-tou/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201105771-bao-shi-yu-shi-tou/">
        </link>
        <updated>2020-11-05T12:25:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="暴力解法">暴力解法</h3>
<pre><code class="language-Python">class Solution:
    def numJewelsInStones(self, J: str, S: str) -&gt; int:
        total = 0
        for j in J:
            for s in S:
                if s == j:
                    total+=1
        return total
</code></pre>
<p>很简单，就不多说了，依次遍历，复杂度O(N²)</p>
<h3 id="hash表">hash表</h3>
<pre><code class="language-Python">class Solution:
    def numJewelsInStones(self, J: str, S: str) -&gt; int:
        mp = {x: 0 for x in J}
        for s in S:
            if mp.get(s) is not None:
                mp[s] += 1
        return sum(mp.values())
</code></pre>
<ul>
<li>先创建一个map, 里面存放类型</li>
<li>遍历字符串，如果找到了类型，则map里面的值+1</li>
<li>累加所有map的value</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201104（57. 插入区间）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020110457-cha-ru-qu-jian/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020110457-cha-ru-qu-jian/">
        </link>
        <updated>2020-11-04T09:37:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>今天的每日一题不是自己想的，虽然理解了，但是感觉还是别人讲的更好，所以就随便打个卡了！
</code></pre>
<pre><code class="language-Python">class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:
        ans = []
        done = False
        left, right= newInterval
        for x, y in intervals:
            if x &gt; right:
                if not done:
                    ans.append([left, right])
                    done = True
                ans.append([x, y])
            elif y &lt; left:
                ans.append([x, y])
            else:
                left = min(left, x)
                right = max(right, y)
        if not done:
            ans.append([left, right])

        return ans

</code></pre>
<p>还是直接去题解吧，虽然今天很敷衍。</p>
<p>题解 <a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/</a></p>
<p>注意点:</p>
<ul>
<li>
<p>2个区间的交集怎么取</p>
</li>
<li>
<p>done标志位是为了不漏掉数据</p>
</li>
<li>
<p>新区间有3种情况</p>
<p>分别落在已有区间的左侧 右侧和中间</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题之20201103（941. 有效的山脉数组）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201103941-you-xiao-de-shan-mai-shu-zu/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201103941-you-xiao-de-shan-mai-shu-zu/">
        </link>
        <updated>2020-11-03T02:59:27.000Z</updated>
        <content type="html"><![CDATA[<h5 id="首先要弄清楚题目的意图曾经在字节面试遇到过类似的题目但那题是需要找出这个峰值">首先要弄清楚题目的意图，曾经在字节面试遇到过类似的题目，但那题是需要找出这个峰值。</h5>
<h5 id="所以解法也肯定不一样">所以解法也肯定不一样。</h5>
<p>官方给的题解是直接遍历，我们这里采用双指针分别从头和尾往中间遍历，如果山脉符合要求，那么<strong>2个指针会停在同一个山脉</strong>。</p>
<hr>
<pre><code class="language-Python">class Solution:
    def validMountainArray(self, A: List[int]) -&gt; bool:
        start, end = 0, len(A)-1
        # 保证start在正常范围并且左边的值小于右边, 循环如果退出，那么左侧的
        # 峰值也就找到了
        while start &lt; len(A)-1 and A[start] &lt; A[start+1]:
            start += 1
        # 右侧同理，保证左值大于右值
        while end &gt; 0 and A[end-1] &gt; A[end] :
            end -= 1
        # 这里需要注意的是，start可能和end在0索引处相遇，比如[2, 1]
        # 所以需要保证他们不在数组两端相遇
        # 如果数组为[] start != end 会返回False
        return start == end and 0 &lt; start &lt; len(A)-1

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-714c6d9fb6c34d44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="777.jpg" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题之20201102（349. 两个数组的交集）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201102349-liang-ge-shu-zu-de-jiao-ji/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201102349-liang-ge-shu-zu-de-jiao-ji/">
        </link>
        <updated>2020-11-02T12:05:18.000Z</updated>
        <summary type="html"><![CDATA[<p>空间换时间，hash表2次遍历(Python)</p>
<ul>
<li>
<p>潇洒解法:</p>
<p>利用Python的set数据结构，完成交集操作</p>
</li>
</ul>
<pre><code class="language-Python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        return list(set(nums1) &amp; set(nums2))

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-650c186e46412d86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.jpg" loading="lazy"></figure>
<ul>
<li>
<p>啰嗦解法（但很快）</p>
<p>先建立一个dict，遍历数组1，然后将数组里面的值都放到temp里面，由于dict本身不能有重复的key，相当于天然过滤掉了重复的数据此步骤约等于set(nums1)</p>
<p>接着就是取并集，遍历数组2，如果数组2的元素在temp里面出现，则添加到result数组中。</p>
<p><strong>但是这里要注意的是，result可能重复添加</strong></p>
<p>所以我们在添加一个数字到result以后，将temp里面该数字对应的value改成False，以防重复添加。</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-1ef3c12edec440d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="222.jpg" loading="lazy"></figure>
<pre><code class="language-Python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        temp = {}
        result = []
        for n in nums1:
            temp[n] = True
        for x in nums2:
            if temp.get(x):
                result.append(x)
                temp[x] = False
        return result
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>空间换时间，hash表2次遍历(Python)</p>
<ul>
<li>
<p>潇洒解法:</p>
<p>利用Python的set数据结构，完成交集操作</p>
</li>
</ul>
<pre><code class="language-Python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        return list(set(nums1) &amp; set(nums2))

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-650c186e46412d86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.jpg" loading="lazy"></figure>
<ul>
<li>
<p>啰嗦解法（但很快）</p>
<p>先建立一个dict，遍历数组1，然后将数组里面的值都放到temp里面，由于dict本身不能有重复的key，相当于天然过滤掉了重复的数据此步骤约等于set(nums1)</p>
<p>接着就是取并集，遍历数组2，如果数组2的元素在temp里面出现，则添加到result数组中。</p>
<p><strong>但是这里要注意的是，result可能重复添加</strong></p>
<p>所以我们在添加一个数字到result以后，将temp里面该数字对应的value改成False，以防重复添加。</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-1ef3c12edec440d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="222.jpg" loading="lazy"></figure>
<pre><code class="language-Python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        temp = {}
        result = []
        for n in nums1:
            temp[n] = True
        for x in nums2:
            if temp.get(x):
                result.append(x)
                temp[x] = False
        return result
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推荐一个接口测试工具--Apifox]]></title>
        <id>https://wuranxu.github.io/post/tui-jian-yi-ge-jie-kou-ce-shi-gong-ju-apifox/</id>
        <link href="https://wuranxu.github.io/post/tui-jian-yi-ge-jie-kou-ce-shi-gong-ju-apifox/">
        </link>
        <updated>2020-10-12T08:31:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="apifox">Apifox</h3>
<pre><code>今天闲来无事，看到了这款工具。相当于出个小评测吧，说下自己的感受。先放地址:
</code></pre>
<p><a href="https://www.apifox.cn/">Apifox官网</a></p>
<pre><code>具体的介绍都可以在官网看到，官网会比我详细，下面来说说我自己的感受。
</code></pre>
<h3 id="感受">感受</h3>
<pre><code>首先呢，这个工具对于yapi、postman和jmeter的使用者来说肯定是很友好的，因为操作流程基本上一致。

大家可以看到他的首页，基本上长得很想postman的&quot;汉化版&quot;:
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://wuranxu.github.io/post-images/1602491849512.jpg" alt="" loading="lazy"></figure>
<p><mark>但是, 他们也有区别</mark></p>
<pre><code>postman是一个十分纯粹的http调用工具，只需要输入http的url、headers、body等信息即可，他十分轻量，虽然后面也迭代了不少的关于test的功能。

总的来看，这个工具是对接口文档/接口请求/接口测试的一次整合。

当然这种整合也带来了一些麻烦，也就是说你需要录入一个接口的相关信息才能完成对这个接口的请求。因为这毕竟是针对团队，针对自身接口的一个测试工具。所以情有可原，复杂点能够理解。


可是，当我觉得它复杂化了postman的时候，我发现它也有快捷调试的功能。因为有时候很多接口，可能是第三方的，比如我常常试用的[百度api](https://ai.baidu.com/) (这个是宝藏api)，我可能只是需要简单调用下，并不想那么麻烦，可能只需要随手一个调用即可。原来这个便捷调试也是存在的:
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://wuranxu.github.io/post-images/1602492392171.jpg" alt="" loading="lazy"></figure>
<pre><code>打开后长这样, 这才是最纯粹的postman呀！还是汉化版，爱了爱了！
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://wuranxu.github.io/post-images/1602492422864.jpg" alt="" loading="lazy"></figure>
<pre><code>那么有的同学可能会有疑问了，既然你就是个汉化版的postman，为什么我不用postman呢？

我想这个工具吸引我的可能有以下几点:

1. 它解决了我平时不写接口文档的问题，因为平时我自己开发接口完了以后，用postman去调试一下，后续可能需要搜索才能找到对应的数据，而且别人根本不知道这个接口怎么调用，只能口口相传。
2. 它支持换肤功能，对比postman，虽然二者UI类似。
3. 它的测试功能强于postman，支持直接导入接口文档当做测试用例。
4. 它完全支持mock功能，这点基本上和yapi提供的一致，如果后端接口还没编写完毕的时候前端已经可以开始通过mock开始调试了。
5. 如果有现有的接口文档工具，它支持了大部分主流数据的导入，比如yapi、rap、swagger等，接入门槛很低。
</code></pre>
<h3 id="写在最后">写在最后</h3>
<pre><code>这个工具，挺适合小团队，比如2-3人的项目组且公司没有内部统一的接口文档管理平台比如yapi或者rap2或者自研的，例如我要和一个朋友开发一个项目，那我觉得这个就很合适，适合自测，也适合前端提前介入开发，还能输出文档。

但是如果只是个人开发自己的项目或者很简单的项目，在接口数量不多的时候，对测试要求不高，不需要花费时间写测试脚本的时候:
</code></pre>
<p><mark>postman还是最合适的工具</mark></p>
<pre><code>看后续apifox还有新的迭代计划，比如完成性能测试相关，但那时候我觉得可能会收费了吧，对于这种高级功能。其实本人比较欣赏他们的UI设计，毕竟是一个公司的产物，整个设计相对来说还是比较美观的。也期待他们的后续吧！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang下载指定版本（go get）]]></title>
        <id>https://wuranxu.github.io/post/golang-xia-zai-zhi-ding-ban-ben-go-get/</id>
        <link href="https://wuranxu.github.io/post/golang-xia-zai-zhi-ding-ban-ben-go-get/">
        </link>
        <updated>2020-09-29T05:41:48.000Z</updated>
        <content type="html"><![CDATA[<pre><code>是这样的，大概在去年的时候，自己学习grpc写了一些相关的代码包括proto和一些生成的pb。

但是今年发现grpc版本有更新，对应的protoc-gen-go这样的插件也进行了一番更新，而这些更新又和etcd不太兼容。所以为了降级，需要获取旧版本。

如果你用的还是GOPATH管理包，那么我建议你现在开始，使用==go module==来管理，当然这需要你的golang版本在1.11以上~

好了废话不多说了，直接上命令吧！
</code></pre>
<pre><code class="language-shell">go get -u -v github.com/golang/protobuf/protoc-gen-go@v1.2.7
</code></pre>
<pre><code>以上就是下载1.2.7版本protoc-gen-go的方式了！
</code></pre>
<h3 id="使用gomodule注意">使用GOMODULE注意</h3>
<pre><code>首先保证GO111MODULE变量是on, 如果是off的话，可在环境变量更新为on。
</code></pre>
<pre><code class="language-shell">export GO111MODULE=on
</code></pre>
<pre><code>或者更新~/.bash_profile文件设置此变量

如果遇到下载慢或者失败的时候，可以切换GOPROXY源:
</code></pre>
<ul>
<li>GOPROXY源</li>
</ul>
<pre><code class="language-shell"> export GOPROXY=https://goproxy.io 
</code></pre>
<ul>
<li>阿里云源</li>
</ul>
<pre><code class="language-shell">export GOPROXY=https://mirrors.aliyun.com/goproxy/ 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务相关思考(一)]]></title>
        <id>https://wuranxu.github.io/post/wei-fu-wu-xiang-guan-si-kao-yi/</id>
        <link href="https://wuranxu.github.io/post/wei-fu-wu-xiang-guan-si-kao-yi/">
        </link>
        <updated>2020-09-23T10:59:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="声明">声明</h3>
<pre><code>以下内容都是本人很片面的观点，如有错误，请帮忙纠正，非常感谢~
</code></pre>
<h3 id="背景">😢背景</h3>
<pre><code>随着咱们的服务越来越庞大，所编写的功能模块也越来越多，单体应用带来了以下问题：

1. 服务臃肿，一处细小改动往往需要重启所有业务服务；
2. 若某接口故障，则导致所有接口均不可用，可用性低；
3. 业务耦合度过高，不利于业务的扩展，常常会导致牵一发动全身的情况出现；
4. 不适合快速迭代开发，往往开发周期被拖得很长。
</code></pre>
<h3 id="问题">问题</h3>
<pre><code>既然问题出现了，那我们就需要对症下药。试想，我们将服务进行拆分，不同的服务对应不同的业务。

之前的模式好比，10个人在吃一块巨大的蛋糕，服务拆分以后就好像把蛋糕切成10块，然后每个人吃自己那块就行了。

但是咱们的后台系统，可不是吃蛋糕那么简单。思考一下服务拆分后会带来哪些问题？

1. 虽然完成了解耦的工作，但是对于业务有关联性的时候，双方怎么进行交流呢？也就是服务之间如何通信呢？
2. 服务需要统一的入口，假如拆分3个服务，那么每个服务需要占用1个端口，对于前端来说，它怎么知道什么url对应什么服务的地址呢？如果每个服务部署到多台机器呢？

等等~
</code></pre>
<h3 id="思考">思考</h3>
<pre><code>针对第一个问题，其实可以采用http请求进行通信，比如我的获取用户信息隶属于==userService==, 那么我找到对应的域名（ip）就可以进行相关接口的调用，拿到对应的用户信息。

但是！这个方案有个缺点，就是: 我们知道http协议是无状态的，也就是说我1秒钟前请求了这个接口，下一秒他还是会重新建立网络连接，所有流程再进行一遍，这对于服务器资源来说，算是一笔不小的开销。
</code></pre>
<h3 id="grpc">grpc</h3>
<pre><code>那么我们就需要用rpc来取代http协议，市场上有多种框架: grpc, thrift, dubbo等等。
</code></pre>
<p>我们今天就着重说一下<a href="https://grpc.io">grpc</a></p>
<pre><code>gRPC  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.

gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。

简单的说呢，它对比HTTP协议，优势很大。

再来说一下它的缺点:

- 学习门槛较高
- 需要编写proto文件
- 生成的rpc服务是tcp的，未暴露http接口给前端使用
</code></pre>
<h3 id="网关">网关</h3>
<pre><code>其实网关这个东西，也可以不需要，nginx足够使用了。针对第二个问题，其实主要是想给客户端提供一个统一的入口。比如针对https://abc.com/user/*这个路由，将其指向对应的userService即可。而且nginx也有自带的负载均衡的策略，想到这里我不禁陷入了沉思，我得思考一下为什么需要go的网关了~

大概查阅了一下相关资料，可能因为自研网关对比nginx来说定制化更容易吧。
</code></pre>
<p>以下内容参考自 <a href="https://www.v2ex.com/t/684586">关于微服务网关的选择</a>:</p>
<pre><code>&quot;nginx 性能虽强，但功能有限。我们一般只用来做负载均衡和反向代理。后面还是 gateway 来实现做身份验证、鉴权、限流、接口访问日志等功能。&quot;
</code></pre>
]]></content>
    </entry>
</feed>