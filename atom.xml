<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuranxu.github.io</id>
    <title>小克的blog</title>
    <updated>2020-11-16T09:28:34.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuranxu.github.io"/>
    <link rel="self" href="https://wuranxu.github.io/atom.xml"/>
    <subtitle>欢迎来到我的小窝~这里不仅有博客，也有日记。</subtitle>
    <logo>https://wuranxu.github.io/images/avatar.png</logo>
    <icon>https://wuranxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小克的blog</rights>
    <entry>
        <title type="html"><![CDATA[每日一题20201115（55. 跳跃游戏）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020111555-tiao-yue-you-xi/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020111555-tiao-yue-you-xi/">
        </link>
        <updated>2020-11-16T09:27:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="55-跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/16/GQCFVayXdAuWOfB.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法一-贪心算法">方法一: 贪心算法</h3>
<pre><code>维护一个能跳到最大距离的变量，遍历数组，每次更新这个变量。可以遍历完成后比较这个值与数组的长度-1，也可以每次遍历的时候判断是否大于了数组长度-1，如果是则直接return
</code></pre>
<pre><code class="language-Python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        max_distance = 0
        for i, n in enumerate(nums):
            # 当i = 0的时候，最大距离肯定为0，i &gt; max_distance是因为第i个索引的位置都跳不到就更不可能跳到最后一个了，这时候跳出循环
            if i &gt; max_distance and i != 0:
                break
            if n + i &gt; max_distance:
                max_distance = n + i
        # 最后判断是否大于等于数组长度-1（也就是能达到最后一个元素）
        return max_distance &gt;= len(nums) - 1

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-0d39bdabe1cccaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h3 id="方法二-动态规划一开始的思路python直接超时-可以上go">方法二 动态规划（一开始的思路，Python直接超时, 可以上go）</h3>
<pre><code>思路也很简单，类似于跳台阶，维护一个dp数组，看达到最后一个台阶的方式有多少种，并判断他是否大于0.
</code></pre>
<pre><code class="language-go">func canJump(nums []int) bool {
    if len(nums) == 0 {
        return false
    }
    result := make([]int, len(nums), len(nums))
    for i, _ := range nums {
        if i == 0 {
            result[i] = 1
            continue
        }
        for j:=0; j&lt;i; j++ {
            if nums[j] &gt;= i-j {
                result[i] += result[j]
            }
        }
    }
    return result[len(nums)-1] &gt; 0
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/11/16/6FRTiNpX5GsHYvr.png" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201116（11. 盛最多水的容器）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020111611-sheng-zui-duo-shui-de-rong-qi/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020111611-sheng-zui-duo-shui-de-rong-qi/">
        </link>
        <updated>2020-11-16T08:23:21.000Z</updated>
        <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/16/tWVZxO4kfd1BRro.png" alt="image.png" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<pre><code>这题有点像接雨水，但是比接雨水简单的是，这个中间是没有木棍的，所以很容易计算出2根棍子能装多少水。

根据木桶效应，容器装水多少是根据最短那块来决定的。

本题用双指针的方式，首先比较两侧木板较短的那块板子，记录下值，如果右侧小则右侧的指针移动，为啥呢，因为右侧可能会有更高的板子出现。如果这时候右侧的更低了呢？没关系，我们记录了每一次的最大值。
</code></pre>
<pre><code class="language-Python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        i, j = 0, len(height)-1
        max_value = 0
        while i &lt; j:
            # 最大值等于 (j-i) * 短板的高度 与 目前的最大值的比较
            max_value = max(max_value, min(height[i], height[j]) * (j-i))
            if height[i] &lt; height[j]:
                i += 1
            else:
                j -= 1
        return max_value

</code></pre>
<h3 id="感觉max和min耗时很久改造了一下">感觉max和min耗时很久，改造了一下:</h3>
<pre><code class="language-Python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        i, j = 0, len(height)-1
        max_value = 0
        while i &lt; j:
            now_value = height[j] * (j-i) if height[j] &lt; height[i] else height[i] * (j-i)
            if now_value &gt; max_value:
                max_value = now_value   
            if height[i] &lt; height[j]:
                i += 1
            else:
                j -= 1
        return max_value
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/11/16/87Z51lgCKFoOasz.png" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201114（1122. 数组的相对排序）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-202011141122-shu-zu-de-xiang-dui-pai-xu/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-202011141122-shu-zu-de-xiang-dui-pai-xu/">
        </link>
        <updated>2020-11-16T07:36:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/16/gexU8aKzlYApIod.png" alt="image.png" loading="lazy"></figure>
<h4 id="重点">重点</h4>
<pre><code>首先注意几个重点：

1. arr1和arr2里最大的元素不会超过1000
2. arr2里面没有重复的元素
3. arr2里面每个元素必定在arr1里面出现
</code></pre>
<h4 id="思路">思路</h4>
<pre><code>1. 先创建一个大小为1001的数组data用来存放arr1中每个元素出现的次数（因为最大值可能是1000），其实这里可以简化，只要这个数组的长度等于max(arr1)+1即可覆盖到所有arr1中的数字；
2. 创建一个大小为arr1的数组或者直接沿用arr1（因为arr1的信息已经被记录到data数组里面了）
3. 遍历arr2，去data中取出arr1中包含arr2元素的数量，分别插入这个新数组并把data里面arr2的相关数据都置为0，保证后续data中只有arr1中特有的元素。
4. 遍历data，把剩下的数据写到新数组。
</code></pre>
<h3 id="方法一">方法一:</h3>
<pre><code class="language-Python">class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&gt; List[int]:
        # 创建一个能容纳arr1最大值的数组
        data = [0] * (max(arr1)+1)
        # 存储arr1中的元素值和数量
        for a in arr1:
            data[a] += 1
        # 最终结果数组
        result = []
        # 把arr2的所有元素写入result数组
        for d in arr2:
            length = data[d]
            for x in range(length):
                result.append(d)
            data[d] = 0
        # i是data中剩余arr1数据的值，可能会有多个，所以需要插入n个i，当n等于0的时候代表n不存在或者n是arr2里的元素，直接continue
        for i, n in enumerate(data):
            if n == 0:
                continue
            for x in range(n):
                result.append(i)
        return result
</code></pre>
<h3 id="优化少用一个result数组直接在arr1修改">优化(少用一个result数组，直接在arr1修改)</h3>
<pre><code class="language-Python">class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&gt; List[int]:
        data = [0] * (max(arr1)+1)
        for a in arr1:
            data[a] += 1
        # 定义一个指针指向当前已经替换的元素
        i = 0
        for d in arr2:
            length = data[d]
            for x in range(i, i+length):
                arr1[x] = d
            i += length
            data[d] = 0
        for j, n in enumerate(data):
            if n == 0:
                continue
            for x in range(i, i+n):
                arr1[x] = j
            i += n
        return arr1
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/11/16/fYDsk2uK1oazCXi.png" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201113（328. 奇偶链表）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201113328-qi-ou-lian-biao/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201113328-qi-ou-lian-biao/">
        </link>
        <updated>2020-11-13T13:43:41.000Z</updated>
        <content type="html"><![CDATA[<p>题目: <a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-771873d65639009d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201113175101832" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<pre><code>定义3个指针，分别为jishu(指向第一个节点), oushu(第一个偶数节点)和oushu_head(第一个偶数节点)
</code></pre>
<pre><code class="language-Python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        if head is None:
            return head
        # 指向第一个奇数节点
        jishu = head
        # 指向第一个偶数节点
        oushu_head = oushu = head.next
        # 当偶数节点不存在或者偶数节点后面没有节点时循环结束
        while oushu is not None and oushu.next is not None:
            # 把偶数的下一个节点（奇数节点）给jishu
            jishu.next = oushu.next
            # jishu奇数指针指向刚才赋予的奇数节点（这样jishu指向第二个奇数节点） 
            jishu = jishu.next
            # 把奇数的下一个节点（偶数节点）指向给偶数
            oushu.next = jishu.next
            # 把偶数节点往后挪一位 此时oushu: 2-&gt;4
            oushu = oushu.next
        # 把oushu_head接入jishu的后面节点（这里其实jishu节点已经到最后一个奇数了）
        jishu.next = oushu_head
        # 返回修改后的head即可
        return head

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-3b1e05acacd3c84c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20201113214140509" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201112（922. 按奇偶排序数组 II）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201112922-an-qi-ou-pai-xu-shu-zu-ii/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201112922-an-qi-ou-pai-xu-shu-zu-ii/">
        </link>
        <updated>2020-11-12T02:50:36.000Z</updated>
        <content type="html"><![CDATA[<h4 id="题目链接-922-按奇偶排序数组-ii">题目链接： <a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkm7yp2bvaj30yg0svmyw.jpg" alt="image.png" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<pre><code>很简单，搞懂问题的核心就行，假设现在有奇数在偶数位上，偶数在奇数位上。

那么我们要做的就是，找到分别在对方位置上的数字，然后交换他们就行。
</code></pre>
<pre><code class="language-Python">class Solution:
    def sortArrayByParityII(self, A: List[int]) -&gt; List[int]:
        # 判断数组大小是否小于等于1，是则直接返回数组
        if len(A) &lt;= 1:
            return A
        # 定义2个指针，i指向第一个偶数位，j指向第一个奇数位
        i, j = 0, 1
        # 循环结束的条件是i或者j超出数组范围
        while i &lt; len(A) and j &lt; len(A):
            # i不是偶数位且j不是奇数位 直接交换，并把i j分别挪到下一个位置
            if A[i] % 2 == 1 and A[j] % 2 == 0:
                A[i], A[j] = A[j], A[i]
                i += 2
                j += 2
            # i不是偶数, j是奇数 那么j去下一个位置
            elif A[i] % 2 == 1:
                j += 2
            # j不是奇数 i去下一个位置
            elif A[j] % 2 == 0:
                i += 2
            # i j位置都正确
            else:
                i += 2
                j += 2
        return A
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkm7ze4k1pj30yg0hadgw.jpg" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201109（15. 三数之和）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020110915-san-shu-zhi-he/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020110915-san-shu-zhi-he/">
        </link>
        <updated>2020-11-09T12:08:27.000Z</updated>
        <content type="html"><![CDATA[<p>题目链接:  <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-69e10b376ebe0244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="解法">解法</h4>
<ul>
<li>
<p><s>暴力法</s></p>
<p>首先可以确定的是暴力法的时间复杂度是O(N³), 所以基本上不考虑此等解法。</p>
</li>
<li>
<p>排序+双指针</p>
<p>思路是先将数组排序（从小到大），然后固定数组的第一位。</p>
<p>定义2个指针（左右指针）分别指向定位数组的后一位和数组最后一位。</p>
<p>如果3个数字加起来比0小，则左指针右移，循环继续。</p>
<p>如果3个数字加起来比0大，则右指针左移，循环继续。</p>
<p>如果3个数字等于0，说明找到了结果，将3个数字放入结果数组中并把左指针右移，右指针左移。</p>
<ol>
<li>
<p>这里需要注意的是，可能会有重复数据产生，为了不产生重复数据，需要确保左移/右移后的值与之前不一致。</p>
</li>
<li>
<p>如果从固定的数字大于0了，说明右侧不可能有结果了，因为右侧都是大于0的数字，加起来不会大于0了。</p>
</li>
<li>
<p>如果固定位置与上一个固定位置的值相同，也会产生重复数据，遇到直接跳过就行。</p>
</li>
</ol>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-1956974a795b240a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="最终代码">最终代码</h4>
<pre><code class="language-Python">class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        # 先对数组进行排序, 为了方便比较元素
        nums = sorted(nums)
        i = 0  # 数组起点
        result = []    # 结果
        while i &lt; len(nums):
            if nums[i] &gt; 0:
                # 大于0的数字可以直接跳过
                break
            if i &gt; 0 and nums[i] == nums[i-1]:
                # 与上一个固定位重复的数字直接跳过
                i += 1
                continue 
            front, back = i+1, len(nums)-1
            while front &lt; back:
                val = nums[i] + nums[back] + nums[front]
                if val &lt; 0:
                    # 说明需要增大数字, front+1
                    front += 1
                elif val &gt; 0:
                    # 说明需要缩小数字, back-1
                    back -= 1
                else:
                    result.append([nums[i], nums[back], nums[front]])
                    front += 1
                    back -= 1
                    # 保证没有重复数组
                    while front &lt; len(nums) and nums[front] == nums[front-1]:
                        front += 1
                    while back &gt;= 0 and nums[back] == nums[back+1]:
                        back -= 1
            i += 1
        return result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201106（169. 多数元素）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201106169-duo-shu-yuan-su/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201106169-duo-shu-yuan-su/">
        </link>
        <updated>2020-11-06T03:23:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-13c477602a678a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="hash表">hash表</h4>
<pre><code>1. 思路很简单，先遍历数组，存储每个元素的个数
2. 遍历hash表，拿到大于 n/2的数字，直接return
</code></pre>
<pre><code class="language-Python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        hash = dict()
        for n in nums:
            if n not in hash:
                hash[n] = 1
            else:
                hash[n] += 1
        for k, v in hash.items():
            if v &gt; len(nums) / 2:
                return k
        return -1

</code></pre>
<p>时间复杂度: O(N)<br>
空间复杂度: O(N)</p>
<h4 id="投票算法">投票算法</h4>
<pre><code>思路很简单，假设你是秦始皇，数组里面有很多其他国家，你们秦兵遇到自己人就+1，遇到其他人就-1，如果你超过了所有国家一半的兵力，那么最后活下来的肯定就是你的士兵。这里之所以能这么确定，是因为题目强调了一定存在多数元素！

代码思路是，开始遍历数组，如果当前的士兵数量是0，则把当前士兵设置为遍历到的元素，比如: 秦

接下来如果遇到秦，则count+1, 遇到的是赵或者其他士兵，则秦和赵士兵同归于尽。下一轮遍历，由于秦的count是0了，则将当前士兵设置为遍历到的士兵。
</code></pre>
<pre><code class="language-Python">class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        if len(nums) == 0:
            return -1
        # 当前士兵数量
        count = 0
        # 当前士兵
        current = None
        for n in nums:
            if count == 0:
                current = n
            count += 1 if n == current else -1
        return current

</code></pre>
<p>时间复杂度: O(N)<br>
空间复杂度: O(1)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201105（771. 宝石与石头）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201105771-bao-shi-yu-shi-tou/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201105771-bao-shi-yu-shi-tou/">
        </link>
        <updated>2020-11-05T12:25:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="暴力解法">暴力解法</h3>
<pre><code class="language-Python">class Solution:
    def numJewelsInStones(self, J: str, S: str) -&gt; int:
        total = 0
        for j in J:
            for s in S:
                if s == j:
                    total+=1
        return total
</code></pre>
<p>很简单，就不多说了，依次遍历，复杂度O(N²)</p>
<h3 id="hash表">hash表</h3>
<pre><code class="language-Python">class Solution:
    def numJewelsInStones(self, J: str, S: str) -&gt; int:
        mp = {x: 0 for x in J}
        for s in S:
            if mp.get(s) is not None:
                mp[s] += 1
        return sum(mp.values())
</code></pre>
<ul>
<li>先创建一个map, 里面存放类型</li>
<li>遍历字符串，如果找到了类型，则map里面的值+1</li>
<li>累加所有map的value</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201104（57. 插入区间）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020110457-cha-ru-qu-jian/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020110457-cha-ru-qu-jian/">
        </link>
        <updated>2020-11-04T09:37:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>今天的每日一题不是自己想的，虽然理解了，但是感觉还是别人讲的更好，所以就随便打个卡了！
</code></pre>
<pre><code class="language-Python">class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:
        ans = []
        done = False
        left, right= newInterval
        for x, y in intervals:
            if x &gt; right:
                if not done:
                    ans.append([left, right])
                    done = True
                ans.append([x, y])
            elif y &lt; left:
                ans.append([x, y])
            else:
                left = min(left, x)
                right = max(right, y)
        if not done:
            ans.append([left, right])

        return ans

</code></pre>
<p>还是直接去题解吧，虽然今天很敷衍。</p>
<p>题解 <a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/</a></p>
<p>注意点:</p>
<ul>
<li>
<p>2个区间的交集怎么取</p>
</li>
<li>
<p>done标志位是为了不漏掉数据</p>
</li>
<li>
<p>新区间有3种情况</p>
<p>分别落在已有区间的左侧 右侧和中间</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题之20201103（941. 有效的山脉数组）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201103941-you-xiao-de-shan-mai-shu-zu/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201103941-you-xiao-de-shan-mai-shu-zu/">
        </link>
        <updated>2020-11-03T02:59:27.000Z</updated>
        <content type="html"><![CDATA[<h5 id="首先要弄清楚题目的意图曾经在字节面试遇到过类似的题目但那题是需要找出这个峰值">首先要弄清楚题目的意图，曾经在字节面试遇到过类似的题目，但那题是需要找出这个峰值。</h5>
<h5 id="所以解法也肯定不一样">所以解法也肯定不一样。</h5>
<p>官方给的题解是直接遍历，我们这里采用双指针分别从头和尾往中间遍历，如果山脉符合要求，那么<strong>2个指针会停在同一个山脉</strong>。</p>
<hr>
<pre><code class="language-Python">class Solution:
    def validMountainArray(self, A: List[int]) -&gt; bool:
        start, end = 0, len(A)-1
        # 保证start在正常范围并且左边的值小于右边, 循环如果退出，那么左侧的
        # 峰值也就找到了
        while start &lt; len(A)-1 and A[start] &lt; A[start+1]:
            start += 1
        # 右侧同理，保证左值大于右值
        while end &gt; 0 and A[end-1] &gt; A[end] :
            end -= 1
        # 这里需要注意的是，start可能和end在0索引处相遇，比如[2, 1]
        # 所以需要保证他们不在数组两端相遇
        # 如果数组为[] start != end 会返回False
        return start == end and 0 &lt; start &lt; len(A)-1

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-714c6d9fb6c34d44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="777.jpg" loading="lazy"></figure>
]]></content>
    </entry>
</feed>