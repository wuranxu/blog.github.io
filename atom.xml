<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuranxu.github.io</id>
    <title>小克的blog</title>
    <updated>2021-03-05T07:13:44.078Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuranxu.github.io"/>
    <link rel="self" href="https://wuranxu.github.io/atom.xml"/>
    <subtitle>欢迎来到我的小窝~这里不仅有博客，也有日记。</subtitle>
    <logo>https://wuranxu.github.io/images/avatar.png</logo>
    <icon>https://wuranxu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小克的blog</rights>
    <entry>
        <title type="html"><![CDATA[每日一题20201201（237. 删除链表中的节点）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201201237-shan-chu-lian-biao-zhong-de-jie-dian/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201201237-shan-chu-lian-biao-zhong-de-jie-dian/">
        </link>
        <updated>2020-12-01T06:07:45.000Z</updated>
        <content type="html"><![CDATA[<h4 id="237-删除链表中的节点"><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8bi2jterj30u00z5teg.jpg" alt="image-20201201140204901" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<pre><code>因为只能在当前节点删除，又找不到current节点的前驱节点，所以要做的很简单：

就是把当前元素的值换成下一个元素的，然后把下下个元素赋给当前元素的下个元素。

比如 4 -&gt; 5 -&gt; 1 -&gt; 9 要删除5的话，可以先把5的值改为1，然后把5的next指向9，即可达到目的
</code></pre>
<pre><code class="language-Python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8bki0lctj30yo0dyjsx.jpg" alt="image-20201201140425531" loading="lazy"></figure>
<pre><code class="language-Go">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8bli0gb0j30yc0e23zy.jpg" alt="image-20201201140523009" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201130（面试题 17.16. 按摩师）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201130mian-shi-ti-1716-an-mo-shi/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201130mian-shi-ti-1716-an-mo-shi/">
        </link>
        <updated>2020-11-30T12:07:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="面试题-1716-按摩师"><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/">面试题 17.16. 按摩师</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7fozbps8j30u00vptdy.jpg" alt="image-20201130194133134" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<pre><code>典型的动态规划题目，存在多个子问题。这题与打家劫舍一模一样

这边我们设f(n)为接纳前N个客户的时长, a为预约数组

当n = 0的时候，显然f(n) = 0

当n = 1的时候，显然f(n) = a[n]

当n &gt;= 2的时候，f(n) = max(f(n-2) + a[n], f(n-1))

分2种情况，接纳第n个客户的话，那么就不能接相邻的客户a[n-1]了，所以总数为f(n-2) + a[n]

如果不接纳第n个客户，那么总数就和f(n-1)一样了。我们是为了求最大的解，所以要取2者的最大值。
</code></pre>
<pre><code class="language-Go">// 这不就是打家劫舍吗？

func massage(nums []int) int {
    // 假设她不接第n个人
    // n == 1 f(n) = a[n]
    // n == 2 f(n) = max(a[n], a[n-1])
    // f(n) = max(f(n-1), f(n-2)+a[n])
    if len(nums) == 0 {
        return 0
    }
    first, second := 0, nums[0]
    for i:=1;i&lt;len(nums);i++ {
        first, second = second, max(first+nums[i], second)
    }
    return second
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7fnr4hhwj30yy0i2mz1.jpg" alt="image-20201130194020286" loading="lazy"></figure>
<pre><code class="language-Python">class Solution:
    def massage(self, nums: List[int]) -&gt; int:
        if len(nums) == 0:
            return 0
        first, second = 0, nums[0]
        for n in nums[1:]:
            first, second = second, max(first+n, second)
        return second
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7fwfzw1tj310u0e6abm.jpg" alt="image-20201130194844069" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201129*（700. 二叉搜索树中的搜索）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201129700-er-cha-sou-suo-shu-zhong-de-sou-suo/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201129700-er-cha-sou-suo-shu-zhong-de-sou-suo/">
        </link>
        <updated>2020-11-30T12:06:48.000Z</updated>
        <content type="html"><![CDATA[<h4 id="700-二叉搜索树中的搜索"><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7g403logj30yu0u0tc2.jpg" alt="image-20201130195559871" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<pre><code>首先搞清楚二叉搜索树的机制，左儿子的值都小于当前节点，右儿子的值都大于当前节点

然后就可以快速写出程序了，用递归很好实现

1. 相等直接return
2. 小于当前节点，直接去树节点的左子树寻找
3. 大于当前节点，去树节点的右子树寻找
</code></pre>
<pre><code class="language-Python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode:
        if root is None:
            return None
        if val == root.val:
            return root
        elif val &gt; root.val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7g6e7vfij311a0kiq57.jpg" alt="image-20201130195817737" loading="lazy"></figure>
<pre><code class="language-Go">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return nil
    }
    if val &lt; root.Val {
        return searchBST(root.Left, val)
    }
    if val &gt; root.Val {
        return searchBST(root.Right, val)
    }  
    return root
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl7gc03g6cj310y0esdhc.jpg" alt="image-20201130200341005" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201123（62. 不同路径）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020112362-bu-tong-lu-jing/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020112362-bu-tong-lu-jing/">
        </link>
        <updated>2020-11-30T12:05:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="62-不同路径"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/6053915-56f351d58b2e3ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<pre><code>这题很简单，直接动态规划即可。

公式如下:

# 到达i j坐标可以从上往下也可以从左往右
f(i, j) = f(i-1, j) + f(i, j-1)  (当i &gt; 0 and j &gt; 0)

f(i, j) = 1  (当i=0或者j=0)  靠边只有1种方案
</code></pre>
<pre><code class="language-Python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        if m == 0 or n == 0:
            return 0
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for x in range(m):
            for y in range(n):
                if x == 0 or y == 0:
                    dp[x][y] = 1
                else:
                    dp[x][y] = dp[x-1][y] + dp[x][y-1]
        return dp[m-1][n-1]

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-530baaab2cc83c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201120（147. 对链表进行插入排序）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201120147-dui-lian-biao-jin-xing-cha-ru-pai-xu/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201120147-dui-lian-biao-jin-xing-cha-ru-pai-xu/">
        </link>
        <updated>2020-11-20T06:42:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="147-对链表进行插入排序"><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkvl8kkbehj30u011a79m.jpg" alt="image-20201120134633194" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<pre><code>维护一个排好序的链表，剩下的值如果比已排好的大，直接放到尾部，如果比之前小，则从链表头遍历，找到对应的位置并插入。

为了很好找到链表头，需要设置一个哑节点。
</code></pre>
<pre><code class="language-Python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        # 1. 如果链表为空，直接return None
        if head is None:
            return None
        # 2. 创建一个哑节点, 指向head
        pre = ListNode(0)
        pre.next = head

        # 3. sorted_data为已经排好序的数据，current为当前要排序的元素
        sorted_data = head
        current = head.next
        
        # 4. 循环的结束条件是current走到None也就是走到最后一个元素
        while current is not None:
            # 当最后一个排好序的元素的值比待排序的值小，则sorted_data后移一位
            if sorted_data.val &lt;= current.val:
                sorted_data = sorted_data.next
            else:
                # prev为头节点，为了不影响哑节点
                prev = pre
                # 找到排好序的第一个大于当前值的节点
                while prev.next.val &lt;= current.val:
                    prev = prev.next
                # 这里要注意，prev目前指向的是第一个大于当前值的节点
                # 这里sorted_data.next = current.next
                # 是因为当前值总是在sorted_data的下一位
                # 这里相当于是把当前节点撤下，挪到前面去
                sorted_data.next = current.next
                current.next = prev.next
                prev.next = current
            # 当前节点继续走，往后挪一位
            current = sorted_data.next
        # 返回哑节点的下一位即可
        return pre.next

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkvmu38wlpj30wy0e4wfz.jpg" alt="image-20201120144152739" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201119（283. 移动零）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201119283-yi-dong-ling/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201119283-yi-dong-ling/">
        </link>
        <updated>2020-11-19T02:48:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="283-移动零"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkua7o18rbj31040j4go1.jpg" alt="image-20201119103934250" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<p><em>双指针</em></p>
<pre><code>左指针指向左边已经排好序的尾部，右指针指向当前数字，右指针如果指向的数字不为0，则交换左右指针。

注意：当非0数字在前面时，左右指针会相等。
</code></pre>
<pre><code class="language-Python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        if len(nums) == 0:
            return
        i = j = 0
        while j &lt; len(nums):
            if nums[j] != 0:
                # 如果i和j不等则替换
                if i != j:
                    nums[i], nums[j] = nums[j], nums[i]
                i += 1
            j += 1 
               
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkuab5jarbj30y60eeta7.jpg" alt="image-20201119104255205" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201118（31. 下一个排列）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020111831-xia-yi-ge-pai-lie/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020111831-xia-yi-ge-pai-lie/">
        </link>
        <updated>2020-11-18T06:28:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="31-下一个排列"><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktavcwbfsj30u00zedjn.jpg" alt="image-20201118141644763" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<p>首先说一下什么是字典序，把1 2 3当作a b c的话，abc有6种排列顺序。</p>
<pre><code>abc acb bac bca cab cba
</code></pre>
<p>上图就是字典序，题目的要求狠简单： 找到下一个字典序，如果没有的话，则输出最小的序号。</p>
<p>首先明确一下，没有下一个序列的情况，那么就是大的全部在前面，所以只需要反转数组就行，就可以回到最小的序列。</p>
<pre><code>再看有下一个排序的情况，我们需要先从右侧找到一个比最右边数字小的数.

然后再和右边第一个大于这个数的数进行交换，以571632为例子：

第一个小于右侧数字的数是1，第一个大于1的数字是2，交换之后:

572631, 由于之前确定的，是通过升序找到的1，所以还需要反转2后面的数字: 572136 就是最终结果了！

正好可以和上面反转的一起处理。
</code></pre>
<pre><code class="language-Python">class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        # 左侧的第一个非升序数字，这里也可以len(nums)-2
        j = len(nums)-1
        while j-1 &gt;= 0:
            if nums[j] &gt; nums[j-1]:
                break
            j -= 1
        # 如果j-1&gt;=0说明找到了这个数字，否则说明数组
        # 是降序排列的
        if j-1 &gt;= 0:
            right = len(nums)-1
            # 找到右边第一个大于nums[j-1]的数字
            while right &gt; j-1 and nums[right] &lt;= nums[j-1]:
                right -= 1
            # 交换他们
            nums[j-1], nums[right] = nums[right], nums[j-1]
            self.reverse(nums, j, len(nums)-1)
        else:
            self.reverse(nums, 0, len(nums)-1)
            
    # 反转数组
    def reverse(self, nums, i, j):
        while i &lt; j:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j -= 1
        return nums

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktb6z1z4hj30xs0e03zz.jpg" alt="image-20201118142757008" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日二题20201117（34. 在排序数组中查找元素的第一个和最后一个位置）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-er-ti-2020111734-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-er-ti-2020111734-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi/">
        </link>
        <updated>2020-11-17T07:11:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gks6dz1e10j310a0r2adq.jpg" alt="image-20201117145554994" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<p>看到排序数组，基本上二分解法占一半，记得刚开始去字节面试的时候，面试官出了一题找出数组（先递增再递减）的峰值，也就是什么时候开始递减的。</p>
<p>答的是扫描，那样如果峰值很靠后的话，算法不是最优解，利用二分可以达到O(logN)，虽然最终在面试官的引导下一步一步写了出来，不过肯定有很多bug吧。</p>
<pre><code>好像说了许多废话，说思路，首先找到那个匹配的数字，如果找不到，直接return [-1, -1]

如果找到了，2个while循环，一左一右开始找最小和最大索引。
</code></pre>
<pre><code class="language-Python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
        low, high = 0, len(nums)-1
        # start是标志位 确认是否找到target
        start = None
        while low &lt;= high:
            mid = (low + high) // 2
            if nums[mid] &gt; target:
                high = mid - 1
            elif nums[mid] &lt; target:
                low = mid + 1
            else:
                start = mid
                break
        if start is None:
            return [-1, -1]
        # 否则开始寻找两侧的节点
        left = right = start
        while left &gt;= 0:
            # 如果左侧的不等于target了直接退出循环
            if left - 1 &lt; 0 or nums[left-1] != target:
                break
            left -= 1

        while right &lt; len(nums):
            if right + 1 &gt;= len(nums) or nums[right+1] != target:
                break
            right += 1
        
        return left ,right

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gks6sfywz0j30xy0eg75t.jpg" alt="image-20201117151000953" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201117（221. 最大正方形）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-20201117221-zui-da-zheng-fang-xing/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-20201117221-zui-da-zheng-fang-xing/">
        </link>
        <updated>2020-11-17T03:31:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="221-最大正方形"><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h4>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkrzqo43nvj30yy0oatb4.jpg" alt="image-20201117110606881" loading="lazy"></figure>
<h3 id="动态规划">动态规划</h3>
<pre><code>求的是最大面积，可以转换为求最大边长。

创建一个二维数组dp

dp是以i, j坐标为右下角的正方形的最大边长。

状态转移方程式：

matrix[i][j] == &quot;1&quot;的时候:
f(i, j) = min(f(i-1, j), f(i, j-1), f(i-1, j-1)) + 1 

matrix[i][j] == &quot;0&quot;的时候，以这个位置为边的长度肯定为0：

 f(i, j) = 0
</code></pre>
<pre><code class="language-Python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        # 判断数组是否为空
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return 0
        dp = [[0 for _ in n] for n in matrix]
        # 定义最大边长
        max_len = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                # 如果i = 0 或者 j = 0 他们是靠边的，所以最多只能以他们本身为边
                if i == 0 or j == 0:
                    dp[i][j] = int(matrix[i][j])
                    if dp[i][j] &gt; max_len:
                        max_len = dp[i][j]
                    continue
                if matrix[i][j] == '0':
                    dp[i][j] = 0
                else:
                    # 找到3个之中最小的+1，因为已经确定matrix[i][j]不为'0'
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    if dp[i][j] &gt; max_len:
                        max_len = dp[i][j]
        return max_len * max_len

</code></pre>
<hr>
<p><strong>需要注意的是，matrix里面的元素都是字符串不是int</strong></p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkrzpe79huj30ye0eita8.jpg" alt="image-20201117110450683" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一题20201115（55. 跳跃游戏）]]></title>
        <id>https://wuranxu.github.io/post/mei-ri-yi-ti-2020111555-tiao-yue-you-xi/</id>
        <link href="https://wuranxu.github.io/post/mei-ri-yi-ti-2020111555-tiao-yue-you-xi/">
        </link>
        <updated>2020-11-16T09:27:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="55-跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/11/16/GQCFVayXdAuWOfB.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法一-贪心算法">方法一: 贪心算法</h3>
<pre><code>维护一个能跳到最大距离的变量，遍历数组，每次更新这个变量。可以遍历完成后比较这个值与数组的长度-1，也可以每次遍历的时候判断是否大于了数组长度-1，如果是则直接return
</code></pre>
<pre><code class="language-Python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        max_distance = 0
        for i, n in enumerate(nums):
            # 当i = 0的时候，最大距离肯定为0，i &gt; max_distance是因为第i个索引的位置都跳不到就更不可能跳到最后一个了，这时候跳出循环
            if i &gt; max_distance and i != 0:
                break
            if n + i &gt; max_distance:
                max_distance = n + i
        # 最后判断是否大于等于数组长度-1（也就是能达到最后一个元素）
        return max_distance &gt;= len(nums) - 1

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/6053915-0d39bdabe1cccaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h3 id="方法二-动态规划一开始的思路python直接超时-可以上go">方法二 动态规划（一开始的思路，Python直接超时, 可以上go）</h3>
<pre><code>思路也很简单，类似于跳台阶，维护一个dp数组，看达到最后一个台阶的方式有多少种，并判断他是否大于0.
</code></pre>
<pre><code class="language-go">func canJump(nums []int) bool {
    if len(nums) == 0 {
        return false
    }
    result := make([]int, len(nums), len(nums))
    for i, _ := range nums {
        if i == 0 {
            result[i] = 1
            continue
        }
        for j:=0; j&lt;i; j++ {
            if nums[j] &gt;= i-j {
                result[i] += result[j]
            }
        }
    }
    return result[len(nums)-1] &gt; 0
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/11/16/6FRTiNpX5GsHYvr.png" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
</feed>