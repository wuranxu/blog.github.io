{"posts":[{"title":"每日二题20201117（34. 在排序数组中查找元素的第一个和最后一个位置）","content":"34. 在排序数组中查找元素的第一个和最后一个位置 思路 看到排序数组，基本上二分解法占一半，记得刚开始去字节面试的时候，面试官出了一题找出数组（先递增再递减）的峰值，也就是什么时候开始递减的。 答的是扫描，那样如果峰值很靠后的话，算法不是最优解，利用二分可以达到O(logN)，虽然最终在面试官的引导下一步一步写了出来，不过肯定有很多bug吧。 好像说了许多废话，说思路，首先找到那个匹配的数字，如果找不到，直接return [-1, -1] 如果找到了，2个while循环，一左一右开始找最小和最大索引。 class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: low, high = 0, len(nums)-1 # start是标志位 确认是否找到target start = None while low &lt;= high: mid = (low + high) // 2 if nums[mid] &gt; target: high = mid - 1 elif nums[mid] &lt; target: low = mid + 1 else: start = mid break if start is None: return [-1, -1] # 否则开始寻找两侧的节点 left = right = start while left &gt;= 0: # 如果左侧的不等于target了直接退出循环 if left - 1 &lt; 0 or nums[left-1] != target: break left -= 1 while right &lt; len(nums): if right + 1 &gt;= len(nums) or nums[right+1] != target: break right += 1 return left ,right ","link":"https://wuranxu.github.io/post/mei-ri-er-ti-2020111734-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi/"},{"title":"每日一题20201117（221. 最大正方形）","content":"221. 最大正方形 动态规划 求的是最大面积，可以转换为求最大边长。 创建一个二维数组dp dp是以i, j坐标为右下角的正方形的最大边长。 状态转移方程式： matrix[i][j] == &quot;1&quot;的时候: f(i, j) = min(f(i-1, j), f(i, j-1), f(i-1, j-1)) + 1 matrix[i][j] == &quot;0&quot;的时候，以这个位置为边的长度肯定为0： f(i, j) = 0 class Solution: def maximalSquare(self, matrix: List[List[str]]) -&gt; int: # 判断数组是否为空 if len(matrix) == 0 or len(matrix[0]) == 0: return 0 dp = [[0 for _ in n] for n in matrix] # 定义最大边长 max_len = 0 for i in range(len(matrix)): for j in range(len(matrix[i])): # 如果i = 0 或者 j = 0 他们是靠边的，所以最多只能以他们本身为边 if i == 0 or j == 0: dp[i][j] = int(matrix[i][j]) if dp[i][j] &gt; max_len: max_len = dp[i][j] continue if matrix[i][j] == '0': dp[i][j] = 0 else: # 找到3个之中最小的+1，因为已经确定matrix[i][j]不为'0' dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] &gt; max_len: max_len = dp[i][j] return max_len * max_len 需要注意的是，matrix里面的元素都是字符串不是int ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-20201117221-zui-da-zheng-fang-xing/"},{"title":"每日一题20201115（55. 跳跃游戏）","content":"55. 跳跃游戏 方法一: 贪心算法 维护一个能跳到最大距离的变量，遍历数组，每次更新这个变量。可以遍历完成后比较这个值与数组的长度-1，也可以每次遍历的时候判断是否大于了数组长度-1，如果是则直接return class Solution: def canJump(self, nums: List[int]) -&gt; bool: max_distance = 0 for i, n in enumerate(nums): # 当i = 0的时候，最大距离肯定为0，i &gt; max_distance是因为第i个索引的位置都跳不到就更不可能跳到最后一个了，这时候跳出循环 if i &gt; max_distance and i != 0: break if n + i &gt; max_distance: max_distance = n + i # 最后判断是否大于等于数组长度-1（也就是能达到最后一个元素） return max_distance &gt;= len(nums) - 1 方法二 动态规划（一开始的思路，Python直接超时, 可以上go） 思路也很简单，类似于跳台阶，维护一个dp数组，看达到最后一个台阶的方式有多少种，并判断他是否大于0. func canJump(nums []int) bool { if len(nums) == 0 { return false } result := make([]int, len(nums), len(nums)) for i, _ := range nums { if i == 0 { result[i] = 1 continue } for j:=0; j&lt;i; j++ { if nums[j] &gt;= i-j { result[i] += result[j] } } } return result[len(nums)-1] &gt; 0 } ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-2020111555-tiao-yue-you-xi/"},{"title":"每日一题20201116（11. 盛最多水的容器）","content":"11. 盛最多水的容器 思路 这题有点像接雨水，但是比接雨水简单的是，这个中间是没有木棍的，所以很容易计算出2根棍子能装多少水。 根据木桶效应，容器装水多少是根据最短那块来决定的。 本题用双指针的方式，首先比较两侧木板较短的那块板子，记录下值，如果右侧小则右侧的指针移动，为啥呢，因为右侧可能会有更高的板子出现。如果这时候右侧的更低了呢？没关系，我们记录了每一次的最大值。 class Solution: def maxArea(self, height: List[int]) -&gt; int: i, j = 0, len(height)-1 max_value = 0 while i &lt; j: # 最大值等于 (j-i) * 短板的高度 与 目前的最大值的比较 max_value = max(max_value, min(height[i], height[j]) * (j-i)) if height[i] &lt; height[j]: i += 1 else: j -= 1 return max_value 感觉max和min耗时很久，改造了一下: class Solution: def maxArea(self, height: List[int]) -&gt; int: i, j = 0, len(height)-1 max_value = 0 while i &lt; j: now_value = height[j] * (j-i) if height[j] &lt; height[i] else height[i] * (j-i) if now_value &gt; max_value: max_value = now_value if height[i] &lt; height[j]: i += 1 else: j -= 1 return max_value ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-2020111611-sheng-zui-duo-shui-de-rong-qi/"},{"title":"每日一题20201114（1122. 数组的相对排序）","content":" 重点 首先注意几个重点： 1. arr1和arr2里最大的元素不会超过1000 2. arr2里面没有重复的元素 3. arr2里面每个元素必定在arr1里面出现 思路 1. 先创建一个大小为1001的数组data用来存放arr1中每个元素出现的次数（因为最大值可能是1000），其实这里可以简化，只要这个数组的长度等于max(arr1)+1即可覆盖到所有arr1中的数字； 2. 创建一个大小为arr1的数组或者直接沿用arr1（因为arr1的信息已经被记录到data数组里面了） 3. 遍历arr2，去data中取出arr1中包含arr2元素的数量，分别插入这个新数组并把data里面arr2的相关数据都置为0，保证后续data中只有arr1中特有的元素。 4. 遍历data，把剩下的数据写到新数组。 方法一: class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&gt; List[int]: # 创建一个能容纳arr1最大值的数组 data = [0] * (max(arr1)+1) # 存储arr1中的元素值和数量 for a in arr1: data[a] += 1 # 最终结果数组 result = [] # 把arr2的所有元素写入result数组 for d in arr2: length = data[d] for x in range(length): result.append(d) data[d] = 0 # i是data中剩余arr1数据的值，可能会有多个，所以需要插入n个i，当n等于0的时候代表n不存在或者n是arr2里的元素，直接continue for i, n in enumerate(data): if n == 0: continue for x in range(n): result.append(i) return result 优化(少用一个result数组，直接在arr1修改) class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&gt; List[int]: data = [0] * (max(arr1)+1) for a in arr1: data[a] += 1 # 定义一个指针指向当前已经替换的元素 i = 0 for d in arr2: length = data[d] for x in range(i, i+length): arr1[x] = d i += length data[d] = 0 for j, n in enumerate(data): if n == 0: continue for x in range(i, i+n): arr1[x] = j i += n return arr1 ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-202011141122-shu-zu-de-xiang-dui-pai-xu/"},{"title":"每日一题20201113（328. 奇偶链表）","content":"题目: 328. 奇偶链表 思路 定义3个指针，分别为jishu(指向第一个节点), oushu(第一个偶数节点)和oushu_head(第一个偶数节点) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if head is None: return head # 指向第一个奇数节点 jishu = head # 指向第一个偶数节点 oushu_head = oushu = head.next # 当偶数节点不存在或者偶数节点后面没有节点时循环结束 while oushu is not None and oushu.next is not None: # 把偶数的下一个节点（奇数节点）给jishu jishu.next = oushu.next # jishu奇数指针指向刚才赋予的奇数节点（这样jishu指向第二个奇数节点） jishu = jishu.next # 把奇数的下一个节点（偶数节点）指向给偶数 oushu.next = jishu.next # 把偶数节点往后挪一位 此时oushu: 2-&gt;4 oushu = oushu.next # 把oushu_head接入jishu的后面节点（这里其实jishu节点已经到最后一个奇数了） jishu.next = oushu_head # 返回修改后的head即可 return head ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-20201113328-qi-ou-lian-biao/"},{"title":"每日一题20201112（922. 按奇偶排序数组 II）","content":"题目链接： 922. 按奇偶排序数组 II 思路 很简单，搞懂问题的核心就行，假设现在有奇数在偶数位上，偶数在奇数位上。 那么我们要做的就是，找到分别在对方位置上的数字，然后交换他们就行。 class Solution: def sortArrayByParityII(self, A: List[int]) -&gt; List[int]: # 判断数组大小是否小于等于1，是则直接返回数组 if len(A) &lt;= 1: return A # 定义2个指针，i指向第一个偶数位，j指向第一个奇数位 i, j = 0, 1 # 循环结束的条件是i或者j超出数组范围 while i &lt; len(A) and j &lt; len(A): # i不是偶数位且j不是奇数位 直接交换，并把i j分别挪到下一个位置 if A[i] % 2 == 1 and A[j] % 2 == 0: A[i], A[j] = A[j], A[i] i += 2 j += 2 # i不是偶数, j是奇数 那么j去下一个位置 elif A[i] % 2 == 1: j += 2 # j不是奇数 i去下一个位置 elif A[j] % 2 == 0: i += 2 # i j位置都正确 else: i += 2 j += 2 return A ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-20201112922-an-qi-ou-pai-xu-shu-zu-ii/"},{"title":"每日一题20201109（15. 三数之和）","content":"题目链接: 15. 三数之和 解法 暴力法 首先可以确定的是暴力法的时间复杂度是O(N³), 所以基本上不考虑此等解法。 排序+双指针 思路是先将数组排序（从小到大），然后固定数组的第一位。 定义2个指针（左右指针）分别指向定位数组的后一位和数组最后一位。 如果3个数字加起来比0小，则左指针右移，循环继续。 如果3个数字加起来比0大，则右指针左移，循环继续。 如果3个数字等于0，说明找到了结果，将3个数字放入结果数组中并把左指针右移，右指针左移。 这里需要注意的是，可能会有重复数据产生，为了不产生重复数据，需要确保左移/右移后的值与之前不一致。 如果从固定的数字大于0了，说明右侧不可能有结果了，因为右侧都是大于0的数字，加起来不会大于0了。 如果固定位置与上一个固定位置的值相同，也会产生重复数据，遇到直接跳过就行。 最终代码 class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: # 先对数组进行排序, 为了方便比较元素 nums = sorted(nums) i = 0 # 数组起点 result = [] # 结果 while i &lt; len(nums): if nums[i] &gt; 0: # 大于0的数字可以直接跳过 break if i &gt; 0 and nums[i] == nums[i-1]: # 与上一个固定位重复的数字直接跳过 i += 1 continue front, back = i+1, len(nums)-1 while front &lt; back: val = nums[i] + nums[back] + nums[front] if val &lt; 0: # 说明需要增大数字, front+1 front += 1 elif val &gt; 0: # 说明需要缩小数字, back-1 back -= 1 else: result.append([nums[i], nums[back], nums[front]]) front += 1 back -= 1 # 保证没有重复数组 while front &lt; len(nums) and nums[front] == nums[front-1]: front += 1 while back &gt;= 0 and nums[back] == nums[back+1]: back -= 1 i += 1 return result ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-2020110915-san-shu-zhi-he/"},{"title":"每日一题20201106（169. 多数元素）","content":" hash表 1. 思路很简单，先遍历数组，存储每个元素的个数 2. 遍历hash表，拿到大于 n/2的数字，直接return class Solution: def majorityElement(self, nums: List[int]) -&gt; int: hash = dict() for n in nums: if n not in hash: hash[n] = 1 else: hash[n] += 1 for k, v in hash.items(): if v &gt; len(nums) / 2: return k return -1 时间复杂度: O(N) 空间复杂度: O(N) 投票算法 思路很简单，假设你是秦始皇，数组里面有很多其他国家，你们秦兵遇到自己人就+1，遇到其他人就-1，如果你超过了所有国家一半的兵力，那么最后活下来的肯定就是你的士兵。这里之所以能这么确定，是因为题目强调了一定存在多数元素！ 代码思路是，开始遍历数组，如果当前的士兵数量是0，则把当前士兵设置为遍历到的元素，比如: 秦 接下来如果遇到秦，则count+1, 遇到的是赵或者其他士兵，则秦和赵士兵同归于尽。下一轮遍历，由于秦的count是0了，则将当前士兵设置为遍历到的士兵。 class Solution: def majorityElement(self, nums: List[int]) -&gt; int: if len(nums) == 0: return -1 # 当前士兵数量 count = 0 # 当前士兵 current = None for n in nums: if count == 0: current = n count += 1 if n == current else -1 return current 时间复杂度: O(N) 空间复杂度: O(1) ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-20201106169-duo-shu-yuan-su/"},{"title":"每日一题20201105（771. 宝石与石头）","content":"暴力解法 class Solution: def numJewelsInStones(self, J: str, S: str) -&gt; int: total = 0 for j in J: for s in S: if s == j: total+=1 return total 很简单，就不多说了，依次遍历，复杂度O(N²) hash表 class Solution: def numJewelsInStones(self, J: str, S: str) -&gt; int: mp = {x: 0 for x in J} for s in S: if mp.get(s) is not None: mp[s] += 1 return sum(mp.values()) 先创建一个map, 里面存放类型 遍历字符串，如果找到了类型，则map里面的值+1 累加所有map的value ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-20201105771-bao-shi-yu-shi-tou/"},{"title":"每日一题20201104（57. 插入区间）","content":"今天的每日一题不是自己想的，虽然理解了，但是感觉还是别人讲的更好，所以就随便打个卡了！ class Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: ans = [] done = False left, right= newInterval for x, y in intervals: if x &gt; right: if not done: ans.append([left, right]) done = True ans.append([x, y]) elif y &lt; left: ans.append([x, y]) else: left = min(left, x) right = max(right, y) if not done: ans.append([left, right]) return ans 还是直接去题解吧，虽然今天很敷衍。 题解 https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/ 注意点: 2个区间的交集怎么取 done标志位是为了不漏掉数据 新区间有3种情况 分别落在已有区间的左侧 右侧和中间 ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-2020110457-cha-ru-qu-jian/"},{"title":"每日一题之20201103（941. 有效的山脉数组）","content":"首先要弄清楚题目的意图，曾经在字节面试遇到过类似的题目，但那题是需要找出这个峰值。 所以解法也肯定不一样。 官方给的题解是直接遍历，我们这里采用双指针分别从头和尾往中间遍历，如果山脉符合要求，那么2个指针会停在同一个山脉。 class Solution: def validMountainArray(self, A: List[int]) -&gt; bool: start, end = 0, len(A)-1 # 保证start在正常范围并且左边的值小于右边, 循环如果退出，那么左侧的 # 峰值也就找到了 while start &lt; len(A)-1 and A[start] &lt; A[start+1]: start += 1 # 右侧同理，保证左值大于右值 while end &gt; 0 and A[end-1] &gt; A[end] : end -= 1 # 这里需要注意的是，start可能和end在0索引处相遇，比如[2, 1] # 所以需要保证他们不在数组两端相遇 # 如果数组为[] start != end 会返回False return start == end and 0 &lt; start &lt; len(A)-1 ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201103941-you-xiao-de-shan-mai-shu-zu/"},{"title":"每日一题之20201102（349. 两个数组的交集）","content":"空间换时间，hash表2次遍历(Python) 潇洒解法: 利用Python的set数据结构，完成交集操作 class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 啰嗦解法（但很快） 先建立一个dict，遍历数组1，然后将数组里面的值都放到temp里面，由于dict本身不能有重复的key，相当于天然过滤掉了重复的数据此步骤约等于set(nums1) 接着就是取并集，遍历数组2，如果数组2的元素在temp里面出现，则添加到result数组中。 但是这里要注意的是，result可能重复添加 所以我们在添加一个数字到result以后，将temp里面该数字对应的value改成False，以防重复添加。 class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: temp = {} result = [] for n in nums1: temp[n] = True for x in nums2: if temp.get(x): result.append(x) temp[x] = False return result ","link":"https://wuranxu.github.io/post/mei-ri-yi-ti-zhi-20201102349-liang-ge-shu-zu-de-jiao-ji/"},{"title":"推荐一个接口测试工具--Apifox","content":"Apifox 今天闲来无事，看到了这款工具。相当于出个小评测吧，说下自己的感受。先放地址: Apifox官网 具体的介绍都可以在官网看到，官网会比我详细，下面来说说我自己的感受。 感受 首先呢，这个工具对于yapi、postman和jmeter的使用者来说肯定是很友好的，因为操作流程基本上一致。 大家可以看到他的首页，基本上长得很想postman的&quot;汉化版&quot;: 但是, 他们也有区别 postman是一个十分纯粹的http调用工具，只需要输入http的url、headers、body等信息即可，他十分轻量，虽然后面也迭代了不少的关于test的功能。 总的来看，这个工具是对接口文档/接口请求/接口测试的一次整合。 当然这种整合也带来了一些麻烦，也就是说你需要录入一个接口的相关信息才能完成对这个接口的请求。因为这毕竟是针对团队，针对自身接口的一个测试工具。所以情有可原，复杂点能够理解。 可是，当我觉得它复杂化了postman的时候，我发现它也有快捷调试的功能。因为有时候很多接口，可能是第三方的，比如我常常试用的[百度api](https://ai.baidu.com/) (这个是宝藏api)，我可能只是需要简单调用下，并不想那么麻烦，可能只需要随手一个调用即可。原来这个便捷调试也是存在的: 打开后长这样, 这才是最纯粹的postman呀！还是汉化版，爱了爱了！ 那么有的同学可能会有疑问了，既然你就是个汉化版的postman，为什么我不用postman呢？ 我想这个工具吸引我的可能有以下几点: 1. 它解决了我平时不写接口文档的问题，因为平时我自己开发接口完了以后，用postman去调试一下，后续可能需要搜索才能找到对应的数据，而且别人根本不知道这个接口怎么调用，只能口口相传。 2. 它支持换肤功能，对比postman，虽然二者UI类似。 3. 它的测试功能强于postman，支持直接导入接口文档当做测试用例。 4. 它完全支持mock功能，这点基本上和yapi提供的一致，如果后端接口还没编写完毕的时候前端已经可以开始通过mock开始调试了。 5. 如果有现有的接口文档工具，它支持了大部分主流数据的导入，比如yapi、rap、swagger等，接入门槛很低。 写在最后 这个工具，挺适合小团队，比如2-3人的项目组且公司没有内部统一的接口文档管理平台比如yapi或者rap2或者自研的，例如我要和一个朋友开发一个项目，那我觉得这个就很合适，适合自测，也适合前端提前介入开发，还能输出文档。 但是如果只是个人开发自己的项目或者很简单的项目，在接口数量不多的时候，对测试要求不高，不需要花费时间写测试脚本的时候: postman还是最合适的工具 看后续apifox还有新的迭代计划，比如完成性能测试相关，但那时候我觉得可能会收费了吧，对于这种高级功能。其实本人比较欣赏他们的UI设计，毕竟是一个公司的产物，整个设计相对来说还是比较美观的。也期待他们的后续吧！ ","link":"https://wuranxu.github.io/post/tui-jian-yi-ge-jie-kou-ce-shi-gong-ju-apifox/"},{"title":"golang下载指定版本（go get）","content":"是这样的，大概在去年的时候，自己学习grpc写了一些相关的代码包括proto和一些生成的pb。 但是今年发现grpc版本有更新，对应的protoc-gen-go这样的插件也进行了一番更新，而这些更新又和etcd不太兼容。所以为了降级，需要获取旧版本。 如果你用的还是GOPATH管理包，那么我建议你现在开始，使用==go module==来管理，当然这需要你的golang版本在1.11以上~ 好了废话不多说了，直接上命令吧！ go get -u -v github.com/golang/protobuf/protoc-gen-go@v1.2.7 以上就是下载1.2.7版本protoc-gen-go的方式了！ 使用GOMODULE注意 首先保证GO111MODULE变量是on, 如果是off的话，可在环境变量更新为on。 export GO111MODULE=on 或者更新~/.bash_profile文件设置此变量 如果遇到下载慢或者失败的时候，可以切换GOPROXY源: GOPROXY源 export GOPROXY=https://goproxy.io 阿里云源 export GOPROXY=https://mirrors.aliyun.com/goproxy/ ","link":"https://wuranxu.github.io/post/golang-xia-zai-zhi-ding-ban-ben-go-get/"},{"title":"微服务相关思考(一)","content":"声明 以下内容都是本人很片面的观点，如有错误，请帮忙纠正，非常感谢~ 😢背景 随着咱们的服务越来越庞大，所编写的功能模块也越来越多，单体应用带来了以下问题： 1. 服务臃肿，一处细小改动往往需要重启所有业务服务； 2. 若某接口故障，则导致所有接口均不可用，可用性低； 3. 业务耦合度过高，不利于业务的扩展，常常会导致牵一发动全身的情况出现； 4. 不适合快速迭代开发，往往开发周期被拖得很长。 问题 既然问题出现了，那我们就需要对症下药。试想，我们将服务进行拆分，不同的服务对应不同的业务。 之前的模式好比，10个人在吃一块巨大的蛋糕，服务拆分以后就好像把蛋糕切成10块，然后每个人吃自己那块就行了。 但是咱们的后台系统，可不是吃蛋糕那么简单。思考一下服务拆分后会带来哪些问题？ 1. 虽然完成了解耦的工作，但是对于业务有关联性的时候，双方怎么进行交流呢？也就是服务之间如何通信呢？ 2. 服务需要统一的入口，假如拆分3个服务，那么每个服务需要占用1个端口，对于前端来说，它怎么知道什么url对应什么服务的地址呢？如果每个服务部署到多台机器呢？ 等等~ 思考 针对第一个问题，其实可以采用http请求进行通信，比如我的获取用户信息隶属于==userService==, 那么我找到对应的域名（ip）就可以进行相关接口的调用，拿到对应的用户信息。 但是！这个方案有个缺点，就是: 我们知道http协议是无状态的，也就是说我1秒钟前请求了这个接口，下一秒他还是会重新建立网络连接，所有流程再进行一遍，这对于服务器资源来说，算是一笔不小的开销。 grpc 那么我们就需要用rpc来取代http协议，市场上有多种框架: grpc, thrift, dubbo等等。 我们今天就着重说一下grpc gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持. gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 简单的说呢，它对比HTTP协议，优势很大。 再来说一下它的缺点: - 学习门槛较高 - 需要编写proto文件 - 生成的rpc服务是tcp的，未暴露http接口给前端使用 网关 其实网关这个东西，也可以不需要，nginx足够使用了。针对第二个问题，其实主要是想给客户端提供一个统一的入口。比如针对https://abc.com/user/*这个路由，将其指向对应的userService即可。而且nginx也有自带的负载均衡的策略，想到这里我不禁陷入了沉思，我得思考一下为什么需要go的网关了~ 大概查阅了一下相关资料，可能因为自研网关对比nginx来说定制化更容易吧。 以下内容参考自 关于微服务网关的选择: &quot;nginx 性能虽强，但功能有限。我们一般只用来做负载均衡和反向代理。后面还是 gateway 来实现做身份验证、鉴权、限流、接口访问日志等功能。&quot; ","link":"https://wuranxu.github.io/post/wei-fu-wu-xiang-guan-si-kao-yi/"},{"title":"react hook","content":"🙃背景 在好奇心的驱使下，还是打开了==react hook==的大门，但是有些东西吧，还是得靠自己琢磨琢磨才能体会。 优势 在react hook里，函数式组件也能有状态管理了。它大概长这样！ import React, {useState, useEffect} from 'react'; export default () =&gt; { // count是该函数组件的属性, 初始值是0 const [count, setCount] = useState(0); return ( &lt;div onClick={()=&gt;setCount(count+1)}&gt;当前点击次数为{count}&lt;/div&gt; ) } 对比以前，可以发现这样写出来简单粗暴，几乎可以说是让我放弃了class的编写，但是我想不明白的是，如果一个组件里面有很多state，岂不是要写很多setXXX. 也可能是我自己的组件太过于耦合了，其实该拆的地方应该要拆。 官方给出的解释就是以下好处: 以下内容搬运自掘金: https://juejin.im/post/6844903908335173645 为什么会有 Hook? 在组件之间复用状态逻辑很难 React 提供了一些方法来实现组件的选择性渲染或复用，如 Render Props、高阶组件 等，但这些方法组成的组件也带来了“嵌套地狱”的问题，复杂了组件的结构，增大了阅读理解代码的难度。React 提供了自定义 Hook 来解决上面提到的问题。 复杂组件变得难以理解 在一些复杂的组件中往往都包含了较多的状态逻辑和方法，如组件常常在 componentDidMount 中获取数据。但是，同时在该生命周期中也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。一些原本没关联的的代码因为修改了相同的状态而冗杂在一起。当然 React 也引入了 Redux 用来实现状态管理，但这也引入了很多抽象概念，文件也相对应复杂起来。Hook 将组件中相互关联的部分拆分成更小的函数，而并非强制按照生命周期划分。 难以理解的 class 在组件中使用 class 时，开发者必须去理解 JavaScript 中 this 的工作方式，需要处理事件绑定等等，另外，class 还存在不能很好的压缩等问题。Hook 使你在非 class 的情况下可以使用更多的 React 特性。 我这个初学者的理解（手动微笑） 我是觉得这个hook给我带来最大的感受就是，一个组件的开发变得更加简单了。第一是因为函数组件本来就显得更简练，第二是可以用useEffect的第二个参数去处理生命周期，比之前的componentDidMount等更为简洁。关于使用方面，其实我自己还在使用dva的connect管理状态，用函数组件connect也能使用，所以暂时体会不到。先稍微记录下自己的感受，后面再更！ ","link":"https://wuranxu.github.io/post/react-hook/"},{"title":"刷题日记·开篇","content":" 记录一下自己的刷题过程，里面可能有大概10%的抄答案，实际上估计刷了60道了吧。 😅说实话，做得多了，确实也慢慢熟练了一些吧。做题也是需要套路的，就好像自己以前s6之前从来不会玩旧版女警，改版以后也不会。有一次在诺克萨斯打排位，黄金分段。当时一级团拿了4杀，出门多一个十字镐，还是打不过对面奥巴马。不敢想象一盘被4个队友怒骂，硬撑到20分钟的场景了。于是我下决心一定要练好女警！ 后面看了一些女警的教学，那段时间开始不断练习，之后女警已经成为我拿到手最有把握的英雄了。 做题目也是一样，其实什么事情都是一样，熟能生巧~ 为什么要刷题🤣 有的小伙伴儿可能会有一些疑问，觉得自己只是个测试，为什么要刷题？ 但很多时候，就算你是测试甚至不是测开，外边公司也会对数据结构/算法有一定的要求。针对测开/开发来说，面试手撕算法就更加常见了！ 根据本人这几年的面试经验来说，项目相关的问题是一方面，另一个很重要的方面就是算法题了。某些公司甚至每面都会有，本人在tx的3面就因为这个败下阵来，然而后悔并没有用~ 诀窍🤥 链表: 倒数第N个节点，可以用双指针，通过指针差将慢的指针停留在倒数第N个节点 链表的中间节点，其实也很简单，也是双指针，只不过是快慢指针，快指针一次走2步，慢指针一次走1步，这样快指针走完，慢指针就留在中间节点了。 这样的套路还有很多，还有看到什么二叉树阿之类的，都别太怕，这也是说给我自己听的。其实做下来的感觉也就是模板套一下（当然只针对easy和部分medium），树就是递归，链表大多是while迭代。 HashMap: 很多都是用来临时存储数据，比如1. 两数之和，就可以用hashmap来解决。 我们用hashmap的时候，可以知道key是不可重复的，很多时候是利用了这样的特点。 -- 想起以前一个实况8队友的QQ签名： 上一天自习不难，难的是上一辈自习！ 后续我也会继续更新这个刷题过程，一方面是为了继续鞭策自己，另一方面就是为了加深自己对数据结构与算法的印象。加油吧！ ","link":"https://wuranxu.github.io/post/shua-ti-ri-ji-kai-pian/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 这是业余时间写东西的一个小网站啦 👨‍💻 博主是谁 博主是一名测试开发工程师，目前在上海工作。平时喜欢捣鼓些测试相关的开发工作，是个不折不扣的技术宅。 ⛹ 兴趣爱好 平时偶尔打打LOL，但是水平一直不怎么好。s3开始就是老黄金了，最近都只打大乱斗。有一起的可以加我一起玩呀~ 艾欧尼亚：丶丶君已陌路丶丶 📬 联系我呀 有想一起交流测试/开发技术的伙伴儿们，可以加群一起呀！ 🎧 QQ群号: 450505138 QQ: 619434176(偶尔不在) 微信: wuranxu ","link":"https://wuranxu.github.io/post/about/"},{"title":"写给大家的一个接口测试平台","content":" 🍦初衷 在2018年的时候，来到这家公司，在领导的规划下，完成了接口测试平台从0到1的建设。可惜的是某些方面还是做的不够好吧~希望能够开发一套较为通用，服务大众的产品。毕竟世界上不只是那些大公司，还有很多才起步但没有合适工具支持的小公司。 🍩目前进度 基本上才处于起步阶段，也希望自己能够坚持下去吧~ ","link":"https://wuranxu.github.io/post/xie-gei-da-jia-de-yi-ge-jie-kou-ce-shi-ping-tai/"}]}