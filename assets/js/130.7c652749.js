(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{530:function(t,a,s){"use strict";s.r(a);var _=s(2),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"测试平台系列-36-使用全局变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试平台系列-36-使用全局变量"}},[t._v("#")]),t._v(" 测试平台系列(36) 使用全局变量")]),t._v(" "),a("blockquote",[a("p",[t._v("大家好，这里是老克，一个想和大家一起分享测试开发相关的技术，面试经验和成长经历的博主！")])]),t._v(" "),a("p",[t._v("欢迎大家关注我的公众号: "),a("code",[t._v("米洛的测开日记")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"回顾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回顾"}},[t._v("#")]),t._v(" 回顾")]),t._v(" "),a("p",[t._v("上篇我们已经编写好了全局变量的页面，今天我们就来学习怎么使用他。")]),t._v(" "),a("h3",{attrs:{id:"windows下的环境变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#windows下的环境变量"}},[t._v("#")]),t._v(" Windows下的环境变量")]),t._v(" "),a("p",[t._v("其实说白了，全局变量也就是一个参数的读取->替换的过程。所以我们得先补习一下el表达式的知识。（关于jsonpath，这个我不太熟悉，我不太算Java技术栈的）")]),t._v(" "),a("p",[t._v("我们都知道，在Windows等操作系统里面会有"),a("code",[t._v("环境变量")]),t._v("的概念，比如:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625976420915-image.png",alt:""}})]),t._v(" "),a("p",[t._v("当我们echo "),a("code",[t._v("%JAVA_HOME%")]),t._v('的时候，为什么输出的不是"%JAVA_HOME%"呢？因为windows有相关的约定，当字符串被%%包裹的话，意味着取值会从环境变量里面寻找，如果找不到，就不进行替换:')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625976541530-image.png",alt:"这个变量不存在，所以不进行任何替换操作"}})]),t._v(" "),a("h3",{attrs:{id:"el表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#el表达式"}},[t._v("#")]),t._v(" EL表达式")]),t._v(" "),a("p",[t._v("这是我当时在上上家公司设计的一套变量表示语法，但是意外撞了EL表达式。我约定的是用"),a("code",[t._v("${}")]),t._v("包裹起来的内容都算作变量，这样在接口测试中如果有需要传递变量的情况，就可以用这个方式来解决。")]),t._v(" "),a("p",[t._v("EL表达式源自我现在正在维护的一个JSP的项目，也算是一种猿粪吧！")]),t._v(" "),a("h3",{attrs:{id:"思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),a("p",[t._v("我们现在支持3种变量类型: JSON/YAML/STRING。我们的步骤也很简单:")]),t._v(" "),a("ol",[a("li",[t._v("拿到变量的值（取值）")]),t._v(" "),a("li",[t._v("替换变量为对应的真实值(替换)")])]),t._v(" "),a("h3",{attrs:{id:"编写变量解析器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写变量解析器"}},[t._v("#")]),t._v(" 编写变量解析器")]),t._v(" "),a("ul",[a("li",[t._v("编写解析器基类")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625977011490-image.png",alt:""}})]),t._v(" "),a("p",[t._v("基类有2个方法:")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("解析")])]),t._v(" "),a("li",[a("p",[t._v("取值")]),t._v(" "),a("p",[t._v("解析是一个待实现的方法，因为不同的类型解析器不一样，未来如果需要支持XML类型，那也要重写这个方法。")]),t._v(" "),a("p",[t._v("取值比较通用，目前来讲，我们解析完yaml以后也是一个json对象，所以可以写在基类中。")]),t._v(" "),a("p",[t._v("我们来仔细看看这段代码:")])])]),t._v(" "),a("h2",{attrs:{id:"参数部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数部分"}},[t._v("#")]),t._v(" 参数部分")]),t._v(" "),a("p",[t._v("parse接受2个参数，data是解析后的数据（一般是JSON对象），key是el表达式的路径如: "),a("code",[t._v("JAVA_HOME")]),t._v("。但是我们不能只做最简单的，我们还需要获取深层次路径的值。")]),t._v(" "),a("p",[t._v("举个例子:")]),t._v(" "),a("p",[t._v("全局变量"),a("code",[t._v("INFO")]),t._v("的值是个JSON类型:")]),t._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"wc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"age"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("19")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"hobby"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"play game"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("我们如果只通过INFO取到JSON对象，那是远远不行的，我们还需要能够通过INFO.age取到对应的年龄。所以我们这里编写了get方法。")]),t._v(" "),a("h2",{attrs:{id:"实现过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现过程"}},[t._v("#")]),t._v(" 实现过程")]),t._v(" "),a("p",[t._v("其实道理很简单，我们先通过"),a("code",[t._v(".")]),t._v("去分割字符串，如果是INFO.age，那么字符串就会成为: "),a("code",[t._v('["INFO", "age"]')]),t._v("数组。接着我们从数组的"),a("code",[t._v("第2个")]),t._v("元素去遍历，如果取到的是数字，那么我们就按照数组索引去取值，如果是普通的key，就按照map来取值。")]),t._v(" "),a("p",[t._v("最后做一个"),a("code",[t._v("异常捕获")]),t._v("，防止那种乱写变量的情况出现。如果result是字符串，我们直接返回。如果是数字类型，那我们就将它转为字符串类型。")]),t._v(" "),a("p",[a("em",[t._v("思考")])]),t._v(" "),a("p",[t._v("因为我们现在是取值，后期替换的时候是用replace把"),a("code",[t._v("${INFO.age}")]),t._v("替换为对应的值，如果你的age是19这个数字的话，想一下replace会出错吗？")]),t._v(" "),a("h3",{attrs:{id:"分别实现3种解析器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分别实现3种解析器"}},[t._v("#")]),t._v(" 分别实现3种解析器")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625977761676-image.png",alt:""}})]),t._v(" "),a("p",[t._v("先看string类型，因为他自己不可能再去深层次取值了。")]),t._v(" "),a("p",[a("code",[t._v("说到这里，我突然想到它可以直接索引去取对应的字符串子串，但是我不太建议支持这样的功能。因为索引需要2个值，1个的话比较鸡肋。这样对于我们的el表达式来说不是太统一。")])]),t._v(" "),a("p",[t._v("所以我们直接return value，也就是不需要进行更深层次取值了。")]),t._v(" "),a("p",[t._v("再看JSON和yaml类型，其实就是load了一下数据（将字符串数据转为JSON对象）。")]),t._v(" "),a("h3",{attrs:{id:"编写gconfigdao获取key的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写gconfigdao获取key的方法"}},[t._v("#")]),t._v(" 编写GConfigDao获取key的方法")]),t._v(" "),a("p",[t._v("之前我们的查询变量的方法，都是批量的，或者说是查询一个列表。我们需要一个更精确的搜索，只要一条变量的数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625978608987-image.png",alt:""}})]),t._v(" "),a("p",[t._v("接受key的名字和对应的环境，如果环境不传的话，则不根据环境去查询。因为目前我们用例执行的时候没有跟环境绑定，所以暂时先不传入env，后续备用的字段。")]),t._v(" "),a("p",[a("code",[t._v("这里想到了小方的疑惑，之前可能go写多了，下意识会把err return回去，现在改成Python的写法了。")])]),t._v(" "),a("h3",{attrs:{id:"改写用例的执行部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改写用例的执行部分"}},[t._v("#")]),t._v(" 改写用例的执行部分")]),t._v(" "),a("p",[t._v("在我的理解里面，用例的变量替换是在"),a("code",[t._v("用例执行的第一步")]),t._v("，并且替换的地方只有那几处:")]),t._v(" "),a("ul",[a("li",[t._v("url")]),t._v(" "),a("li",[t._v("request_header")]),t._v(" "),a("li",[t._v("body")])]),t._v(" "),a("p",[t._v("因为目前还没有前后置条件，所以后续再补充，断言里的内容也如此，它们独立于用例之外了。")]),t._v(" "),a("h3",{attrs:{id:"改造executor类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改造executor类"}},[t._v("#")]),t._v(" 改造Executor类")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625979191250-image.png",alt:""}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("新增fields字段，存放需要替换变量的字段。")])]),t._v(" "),a("li",[a("p",[t._v("编写parse_gconfig方法")]),t._v(" "),a("p",[t._v("依次去修改各个字段中的变量。")])]),t._v(" "),a("li",[a("p",[t._v("编写get_parser")]),t._v(" "),a("p",[t._v("这个是根据gconfig类型来获取对应的解析器，如果0则为String解析器，1则是JSON解析器，2则是Yaml解析器。")])]),t._v(" "),a("li",[a("p",[t._v("parse_field")]),t._v(" "),a("p",[t._v("这个方法是先获取原始字段里面的el表达式，然后依次去解析到真实数据，最后再修改TestCase的字段（注意只是临时修改，不修改数据表）。")])])]),t._v(" "),a("p",[t._v("目前代码优化点### 在run方法加上有2处:")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("通过key获取配置的时候，一旦一个字段里面出现2个参数的时候，会获取2次key，也就是查询db2次，这样开销很大")])]),t._v(" "),a("li",[a("code",[t._v("每次跑都会执行db，开销巨大，可以考虑本地缓存或者redis缓存。")])])]),t._v(" "),a("h3",{attrs:{id:"修改run方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改run方法"}},[t._v("#")]),t._v(" 修改run方法")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625979519178-image.png",alt:""}})]),t._v(" "),a("p",[t._v("--")]),t._v(" "),a("h3",{attrs:{id:"看下效果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看下效果"}},[t._v("#")]),t._v(" 看下效果")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625979729749-image.png",alt:""}})]),t._v(" "),a("p",[t._v("可以看到参数都已经进行了替换，我们再来看看变量"),a("code",[t._v("BASIC_CONFIG")]),t._v("的内容:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625979817974-image.png",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pity.fun/picture/2021-7-11/1625980828090-image.png",alt:""}})]),t._v(" "),a("p",[t._v("--")]),t._v(" "),a("p",[t._v("那么，本期内容到这里就结束了。")]),t._v(" "),a("p",[t._v("在线演示地址: "),a("a",{attrs:{href:"http://47.112.32.195/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://47.112.32.195/"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("前端代码仓库: "),a("a",{attrs:{href:"https://github.com/wuranxu/pityWeb",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/wuranxu/pityWeb"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("后端代码仓库: "),a("a",{attrs:{href:"https://github.com/wuranxu/pity",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/wuranxu/pity"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);